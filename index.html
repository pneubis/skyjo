<!DOCTYPE html>
<html lang="fr">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no, maximum-scale=1.0">
<title>Skyjo Multijoueur</title>
<link rel="icon" href="https://public-frontend-cos.metadl.com/mgx/img/favicon_atoms.ico" type="image/x-icon">
<script src="https://unpkg.com/peerjs@1.5.4/dist/peerjs.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/davidshimjs-qrcodejs@0.0.2/qrcode.min.js"></script>
<style>
*{margin:0;padding:0;box-sizing:border-box;-webkit-tap-highlight-color:transparent}
body{font-family:'Segoe UI',system-ui,-apple-system,sans-serif;background:#1a1a2e;color:#fff;min-height:100vh;overflow-x:hidden;user-select:none}
.screen{display:none;flex-direction:column;align-items:center;justify-content:center;min-height:100vh;padding:16px}
.screen.active{display:flex}
h1{font-size:2.2em;font-weight:700;margin-bottom:8px;background:linear-gradient(135deg,#9b59b6,#3498db);-webkit-background-clip:text;-webkit-text-fill-color:transparent;background-clip:text}
h2{font-size:1.4em;font-weight:600;margin-bottom:16px;color:#ccc}
.subtitle{color:#888;font-size:0.9em;margin-bottom:24px}
button{background:linear-gradient(135deg,#9b59b6,#8e44ad);color:#fff;border:none;padding:14px 32px;border-radius:12px;font-size:1em;font-weight:600;cursor:pointer;transition:all .2s;touch-action:manipulation;min-height:48px}
button:hover{transform:translateY(-2px);box-shadow:0 4px 15px rgba(155,89,182,.4)}
button:active{transform:translateY(0)}
button.secondary{background:rgba(255,255,255,.1);backdrop-filter:blur(10px)}
button.secondary:hover{background:rgba(255,255,255,.2);box-shadow:none}
button.danger{background:linear-gradient(135deg,#e74c3c,#c0392b)}
input{background:rgba(255,255,255,.1);border:2px solid rgba(255,255,255,.15);color:#fff;padding:14px 18px;border-radius:12px;font-size:1em;width:100%;max-width:320px;outline:none;transition:border-color .2s}
input:focus{border-color:#9b59b6}
input::placeholder{color:#666}
.btn-group{display:flex;gap:12px;flex-wrap:wrap;justify-content:center;margin-top:16px}
.card-container{display:flex;flex-direction:column;gap:4px;margin:8px}
.card-row{display:flex;gap:4px;justify-content:center}

/* Cards */
.card{width:52px;height:72px;border-radius:8px;display:flex;align-items:center;justify-content:center;font-size:1.2em;font-weight:700;cursor:pointer;transition:all .2s;position:relative;border:2px solid rgba(255,255,255,.1)}
.card:active{transform:scale(.95)}
.card.face-down{background:linear-gradient(135deg,#4a4a6a,#3a3a5a);color:transparent;cursor:pointer}
.card.face-down::after{content:'?';color:#666;font-size:1.4em;position:absolute}
.card.eliminated{opacity:0;pointer-events:none;transform:scale(0)}
.card.selectable{animation:pulse 1s infinite;box-shadow:0 0 12px rgba(155,89,182,.6)}
.card.highlight{box-shadow:0 0 15px rgba(255,255,255,.5)}
@keyframes pulse{0%,100%{box-shadow:0 0 8px rgba(155,89,182,.4)}50%{box-shadow:0 0 18px rgba(155,89,182,.8)}}

.card.val-neg2{background:linear-gradient(135deg,#27ae60,#2ecc71);color:#fff}
.card.val-neg1{background:linear-gradient(135deg,#2ecc71,#58d68d);color:#fff}
.card.val-0{background:linear-gradient(135deg,#2980b9,#3498db);color:#fff}
.card.val-1,.card.val-2,.card.val-3,.card.val-4{background:linear-gradient(135deg,#f39c12,#f1c40f);color:#333}
.card.val-5,.card.val-6,.card.val-7,.card.val-8{background:linear-gradient(135deg,#d35400,#e67e22);color:#fff}
.card.val-9,.card.val-10,.card.val-11,.card.val-12{background:linear-gradient(135deg,#c0392b,#e74c3c);color:#fff}

/* Piles */
.piles{display:flex;gap:20px;align-items:center;justify-content:center;margin:12px 0}
.pile{display:flex;flex-direction:column;align-items:center;gap:6px}
.pile-label{font-size:.75em;color:#888;text-transform:uppercase;letter-spacing:1px}
.pile .card{width:58px;height:80px;font-size:1.4em}

/* Player areas */
.players-area{width:100%;max-width:700px;display:flex;flex-direction:column;gap:12px;padding:8px}
.player-zone{background:rgba(255,255,255,.05);border-radius:12px;padding:10px;border:2px solid transparent;transition:border-color .3s}
.player-zone.current-turn{border-color:#9b59b6}
.player-zone.is-me{border-color:rgba(52,152,219,.5)}
.player-zone.is-me.current-turn{border-color:#9b59b6;box-shadow:0 0 20px rgba(155,89,182,.3)}
.player-header{display:flex;justify-content:space-between;align-items:center;margin-bottom:6px;padding:0 4px}
.player-name{font-weight:600;font-size:.9em}
.player-score{font-size:.85em;color:#888}
.player-badge{font-size:.7em;padding:2px 8px;border-radius:20px;background:rgba(155,89,182,.3);color:#bb86fc}
.turn-indicator{font-size:.7em;color:#f1c40f;font-weight:600}

/* Lobby */
.lobby-box{background:rgba(255,255,255,.05);border-radius:16px;padding:24px;max-width:400px;width:100%;text-align:center}
.lobby-players{list-style:none;margin:16px 0;text-align:left}
.lobby-players li{padding:10px 16px;background:rgba(255,255,255,.05);border-radius:8px;margin-bottom:6px;display:flex;justify-content:space-between;align-items:center}
.lobby-players li .host-badge{font-size:.7em;background:#9b59b6;padding:2px 8px;border-radius:10px}
#qr-container{margin:16px auto;border-radius:12px;background:#fff;padding:8px;display:inline-block}
#qr-container img{display:block;border-radius:4px}
.room-code{font-family:monospace;font-size:1.8em;letter-spacing:4px;color:#bb86fc;margin:8px 0}
.copy-btn{font-size:.8em;padding:8px 16px;margin-top:4px}

/* Game header */
.game-header{width:100%;max-width:700px;display:flex;justify-content:space-between;align-items:center;padding:8px 12px;background:rgba(255,255,255,.05);border-radius:12px;margin-bottom:8px}
.game-status{font-size:.85em;color:#ccc;text-align:center;flex:1}
.round-info{font-size:.75em;color:#888}

/* Action bar */
.action-bar{position:fixed;bottom:0;left:0;right:0;background:rgba(26,26,46,.95);backdrop-filter:blur(10px);padding:12px 16px;display:flex;justify-content:center;gap:10px;border-top:1px solid rgba(255,255,255,.1);z-index:100}
.action-bar button{padding:10px 20px;font-size:.85em}

/* Scores screen */
.scores-table{width:100%;max-width:500px;border-collapse:collapse;margin:16px 0}
.scores-table th,.scores-table td{padding:12px 16px;text-align:center;border-bottom:1px solid rgba(255,255,255,.1)}
.scores-table th{color:#888;font-weight:600;font-size:.85em;text-transform:uppercase}
.scores-table tr.winner{background:rgba(46,204,113,.15)}
.scores-table td.total{font-weight:700;color:#bb86fc}

/* Toast */
.toast{position:fixed;top:20px;left:50%;transform:translateX(-50%);background:rgba(155,89,182,.9);color:#fff;padding:12px 24px;border-radius:12px;font-size:.9em;z-index:200;opacity:0;transition:opacity .3s;pointer-events:none}
.toast.show{opacity:1}

/* Modal */
.modal-overlay{position:fixed;inset:0;background:rgba(0,0,0,.7);display:none;align-items:center;justify-content:center;z-index:300;padding:16px}
.modal-overlay.active{display:flex}
.modal{background:#2a2a4a;border-radius:16px;padding:24px;max-width:400px;width:100%;text-align:center}
.modal h3{margin-bottom:12px;font-size:1.2em}
.modal p{color:#aaa;margin-bottom:16px;font-size:.9em}

/* Scrollable game */
.game-content{width:100%;overflow-y:auto;padding-bottom:80px;display:flex;flex-direction:column;align-items:center}

/* Responsive */
@media(max-width:400px){
  .card{width:44px;height:62px;font-size:1em;border-radius:6px}
  .pile .card{width:50px;height:70px;font-size:1.2em}
  h1{font-size:1.8em}
}
</style>
</head>
<body>

<!-- TOAST -->
<div class="toast" id="toast"></div>

<!-- MODAL -->
<div class="modal-overlay" id="modal">
  <div class="modal">
    <h3 id="modal-title"></h3>
    <p id="modal-text"></p>
    <div class="btn-group" id="modal-buttons"></div>
  </div>
</div>

<!-- SCREEN: MENU -->
<div class="screen active" id="screen-menu">
  <h1>SKYJO</h1>
  <p class="subtitle">Jeu de cartes multijoueur</p>
  <div style="margin:12px 0;width:100%;max-width:320px">
    <input type="text" id="player-name" placeholder="Votre pseudo" maxlength="12" autocomplete="off">
  </div>
  <div class="btn-group" style="margin-top:8px">
    <button onclick="createGame()">Cr√©er une partie</button>
    <button class="secondary" onclick="showJoinScreen()">Rejoindre</button>
  </div>
</div>

<!-- SCREEN: JOIN -->
<div class="screen" id="screen-join">
  <h1>SKYJO</h1>
  <h2>Rejoindre une partie</h2>
  <div style="width:100%;max-width:320px">
    <input type="text" id="room-input" placeholder="Code de la salle" maxlength="6" autocomplete="off" style="text-transform:uppercase;text-align:center;font-size:1.4em;letter-spacing:4px">
  </div>
  <div class="btn-group">
    <button onclick="joinGame()">Rejoindre</button>
    <button class="secondary" onclick="showScreen('screen-menu')">Retour</button>
  </div>
</div>

<!-- SCREEN: LOBBY -->
<div class="screen" id="screen-lobby">
  <div class="lobby-box">
    <h2>Salle d'attente</h2>
    <p class="subtitle">Partagez le code ou le QR code</p>
    <div class="room-code" id="lobby-code"></div>
    <button class="copy-btn secondary" onclick="copyCode()">üìã Copier le lien</button>
    <div id="qr-container"></div>
    <ul class="lobby-players" id="lobby-players"></ul>
    <div class="btn-group">
      <button id="start-btn" onclick="startGame()" style="display:none">Lancer la partie</button>
      <button class="danger" onclick="leaveLobby()">Quitter</button>
    </div>
  </div>
</div>

<!-- SCREEN: GAME -->
<div class="screen" id="screen-game" style="justify-content:flex-start;padding-top:8px">
  <div class="game-header">
    <div class="round-info" id="round-info">Manche 1</div>
    <div class="game-status" id="game-status">En attente...</div>
    <button class="secondary" style="padding:6px 12px;font-size:.75em" onclick="showRules()">?</button>
  </div>
  <div class="game-content" id="game-content">
    <div class="piles" id="piles-area"></div>
    <div class="players-area" id="players-area"></div>
  </div>
  <div class="action-bar" id="action-bar" style="display:none"></div>
</div>

<!-- SCREEN: ROUND SCORES -->
<div class="screen" id="screen-round-scores">
  <h2>Fin de la manche</h2>
  <table class="scores-table" id="round-scores-table"></table>
  <div class="btn-group">
    <button id="next-round-btn" onclick="nextRound()">Manche suivante</button>
  </div>
</div>

<!-- SCREEN: FINAL SCORES -->
<div class="screen" id="screen-final-scores">
  <h1>üèÜ Fin de partie</h1>
  <table class="scores-table" id="final-scores-table"></table>
  <div class="btn-group">
    <button onclick="backToMenu()">Menu principal</button>
  </div>
</div>

<script>
// ============================================================
// SKYJO MULTIPLAYER - Complete Game Logic
// ============================================================

// --- CONSTANTS ---
const CARD_COUNTS = {'-2':5,'-1':10,'0':15,'1':10,'2':10,'3':10,'4':10,'5':10,'6':10,'7':10,'8':10,'9':10,'10':10,'11':10,'12':10};
const ROWS = 3, COLS = 4;
const MAX_PLAYERS = 8;
const END_SCORE = 100;

// --- STATE ---
let peer = null;
let connections = {}; // peerId -> conn
let hostConn = null; // connection to host (if client)
let isHost = false;
let myPeerId = '';
let myName = '';
let roomCode = '';
let gameState = null; // full game state (host manages)
let myPlayerId = '';
let currentScreen = 'screen-menu';

// --- PEER SETUP ---
function generateRoomCode() {
  const chars = 'ABCDEFGHJKLMNPQRSTUVWXYZ23456789';
  let code = '';
  for (let i = 0; i < 5; i++) code += chars[Math.floor(Math.random() * chars.length)];
  return code;
}

function initPeer(id) {
  return new Promise((resolve, reject) => {
    peer = new Peer(id, {
      config: {
        iceServers: [
          { urls: 'stun:stun.l.google.com:19302' },
          { urls: 'stun:stun1.l.google.com:19302' }
        ]
      }
    });
    peer.on('open', (pid) => { myPeerId = pid; resolve(pid); });
    peer.on('error', (err) => {
      console.error('Peer error:', err);
      if (err.type === 'unavailable-id') {
        reject(new Error('Code d√©j√† utilis√©'));
      } else {
        reject(err);
      }
    });
  });
}

// --- MENU ---
function getName() {
  let name = document.getElementById('player-name').value.trim();
  if (!name) name = 'Joueur' + Math.floor(Math.random() * 999);
  return name;
}

function showScreen(id) {
  document.querySelectorAll('.screen').forEach(s => s.classList.remove('active'));
  document.getElementById(id).classList.add('active');
  currentScreen = id;
}

function showJoinScreen() {
  myName = getName();
  showScreen('screen-join');
  document.getElementById('room-input').focus();
}

// --- CREATE GAME (HOST) ---
async function createGame() {
  myName = getName();
  roomCode = generateRoomCode();
  isHost = true;
  
  try {
    await initPeer('skyjo-' + roomCode);
  } catch(e) {
    toast('Erreur: ' + e.message);
    return;
  }
  
  myPlayerId = myPeerId;
  
  // Listen for connections
  peer.on('connection', (conn) => {
    conn.on('open', () => {
      conn.on('data', (data) => handleHostMessage(conn, data));
    });
    conn.on('close', () => handleDisconnect(conn.peer));
  });
  
  // Init lobby state
  gameState = {
    phase: 'lobby',
    players: [{ id: myPeerId, name: myName, isHost: true }],
    round: 0,
    totalScores: {}
  };
  gameState.totalScores[myPeerId] = 0;
  
  showLobby();
}

// --- JOIN GAME (CLIENT) ---
async function joinGame() {
  myName = getName();
  const code = document.getElementById('room-input').value.trim().toUpperCase();
  if (!code) { toast('Entrez un code'); return; }
  roomCode = code;
  isHost = false;
  
  try {
    await initPeer('skyjo-' + roomCode + '-' + Math.random().toString(36).substr(2,4));
  } catch(e) {
    toast('Erreur connexion');
    return;
  }
  
  myPlayerId = myPeerId;
  const hostId = 'skyjo-' + roomCode;
  hostConn = peer.connect(hostId, { reliable: true });
  
  hostConn.on('open', () => {
    hostConn.send({ type: 'join', name: myName, id: myPeerId });
    hostConn.on('data', (data) => handleClientMessage(data));
  });
  
  hostConn.on('close', () => {
    toast('D√©connect√© de l\'h√¥te');
    backToMenu();
  });
  
  hostConn.on('error', (err) => {
    toast('Impossible de rejoindre');
    console.error(err);
  });
  
  // Show lobby (will be updated by host)
  setTimeout(() => {
    if (currentScreen !== 'screen-lobby') {
      showScreen('screen-lobby');
      document.getElementById('lobby-code').textContent = roomCode;
      generateQR();
    }
  }, 1000);
}

// --- HOST MESSAGE HANDLING ---
function handleHostMessage(conn, data) {
  if (!gameState) return;
  
  switch(data.type) {
    case 'join':
      if (gameState.phase !== 'lobby') {
        conn.send({ type: 'error', msg: 'Partie d√©j√† en cours' });
        return;
      }
      if (gameState.players.length >= MAX_PLAYERS) {
        conn.send({ type: 'error', msg: 'Salle pleine' });
        return;
      }
      connections[data.id] = conn;
      gameState.players.push({ id: data.id, name: data.name, isHost: false });
      gameState.totalScores[data.id] = 0;
      broadcastState();
      toast(data.name + ' a rejoint');
      break;
      
    case 'action':
      handlePlayerAction(data.playerId, data.action);
      break;
  }
}

function handleDisconnect(peerId) {
  if (!gameState) return;
  delete connections[peerId];
  if (gameState.phase === 'lobby') {
    gameState.players = gameState.players.filter(p => p.id !== peerId);
    delete gameState.totalScores[peerId];
    broadcastState();
  }
  // During game, mark as disconnected but keep in game
}

// --- CLIENT MESSAGE HANDLING ---
function handleClientMessage(data) {
  switch(data.type) {
    case 'state':
      gameState = data.state;
      renderFromState();
      break;
    case 'error':
      toast(data.msg);
      break;
    case 'toast':
      toast(data.msg);
      break;
  }
}

// --- BROADCAST ---
function broadcastState() {
  const msg = { type: 'state', state: gameState };
  Object.values(connections).forEach(conn => {
    try { conn.send(msg); } catch(e) {}
  });
  renderFromState();
}

function broadcastToast(msg) {
  Object.values(connections).forEach(conn => {
    try { conn.send({ type: 'toast', msg }); } catch(e) {}
  });
  toast(msg);
}

function sendToHost(data) {
  if (hostConn && hostConn.open) {
    hostConn.send(data);
  }
}

// --- LOBBY ---
function showLobby() {
  showScreen('screen-lobby');
  document.getElementById('lobby-code').textContent = roomCode;
  generateQR();
  renderLobby();
}

function generateQR() {
  const url = window.location.href.split('?')[0] + '?room=' + roomCode;
  const container = document.getElementById('qr-container');
  container.innerHTML = '';
  try {
    new QRCode(container, {
      text: url,
      width: 180,
      height: 180,
      colorDark: '#1a1a2e',
      colorLight: '#ffffff',
      correctLevel: QRCode.CorrectLevel.M
    });
  } catch(e) {
    // Fallback: show the URL as text if QR generation fails
    container.innerHTML = '<p style="color:#333;font-size:.75em;padding:8px;word-break:break-all">' + url + '</p>';
    console.error('QR generation error:', e);
  }
}

function renderLobby() {
  if (!gameState) return;
  const list = document.getElementById('lobby-players');
  list.innerHTML = gameState.players.map(p => 
    `<li>${p.name} ${p.isHost ? '<span class="host-badge">H√îTE</span>' : ''}${p.id === myPlayerId ? ' (vous)' : ''}</li>`
  ).join('');
  
  const startBtn = document.getElementById('start-btn');
  if (isHost && gameState.players.length >= 2) {
    startBtn.style.display = '';
  } else {
    startBtn.style.display = 'none';
  }
}

function copyCode() {
  const url = window.location.href.split('?')[0] + '?room=' + roomCode;
  navigator.clipboard.writeText(url).then(() => toast('Lien copi√© !')).catch(() => toast(roomCode));
}

function leaveLobby() {
  if (peer) peer.destroy();
  peer = null;
  connections = {};
  hostConn = null;
  gameState = null;
  backToMenu();
}

function backToMenu() {
  if (peer) { peer.destroy(); peer = null; }
  connections = {};
  hostConn = null;
  gameState = null;
  isHost = false;
  showScreen('screen-menu');
}

// --- DECK CREATION ---
function createDeck() {
  const deck = [];
  for (const [val, count] of Object.entries(CARD_COUNTS)) {
    for (let i = 0; i < count; i++) {
      deck.push(parseInt(val));
    }
  }
  return shuffle(deck);
}

function shuffle(arr) {
  const a = [...arr];
  for (let i = a.length - 1; i > 0; i--) {
    const j = Math.floor(Math.random() * (i + 1));
    [a[i], a[j]] = [a[j], a[i]];
  }
  return a;
}

// --- START GAME (HOST ONLY) ---
function startGame() {
  if (!isHost || gameState.players.length < 2) return;
  initRound();
}

function initRound() {
  const deck = createDeck();
  const hands = {};
  const revealed = {};
  
  gameState.players.forEach(p => {
    const cards = [];
    for (let r = 0; r < ROWS; r++) {
      const row = [];
      for (let c = 0; c < COLS; c++) {
        row.push(deck.pop());
      }
      cards.push(row);
    }
    hands[p.id] = cards;
    // All face down
    const rev = [];
    for (let r = 0; r < ROWS; r++) {
      rev.push([false, false, false, false]);
    }
    revealed[p.id] = rev;
  });
  
  // Discard pile starts with one card
  const discardTop = deck.pop();
  
  gameState.round++;
  gameState.phase = 'reveal_initial'; // Each player reveals 2 cards
  gameState.deck = deck;
  gameState.discard = [discardTop];
  gameState.hands = hands;
  gameState.revealed = revealed;
  gameState.eliminated = {}; // track eliminated columns
  gameState.players.forEach(p => {
    gameState.eliminated[p.id] = [false, false, false, false];
  });
  gameState.currentPlayerIndex = -1; // not set yet
  gameState.initialReveals = {}; // playerId -> count of revealed
  gameState.players.forEach(p => gameState.initialReveals[p.id] = 0);
  gameState.turnPhase = null; // 'draw' | 'place' | 'drawn_from_pile'
  gameState.drawnCard = null;
  gameState.drawnFrom = null; // 'deck' | 'discard'
  gameState.lastRoundTriggeredBy = null;
  gameState.lastRoundTurnsLeft = -1;
  gameState.roundScores = {};
  
  broadcastToast('Manche ' + gameState.round + ' - Retournez 2 cartes !');
  broadcastState();
}

// --- PLAYER ACTIONS ---
function performAction(action) {
  if (isHost) {
    handlePlayerAction(myPlayerId, action);
  } else {
    sendToHost({ type: 'action', playerId: myPlayerId, action });
  }
}

function handlePlayerAction(playerId, action) {
  if (!isHost || !gameState) return;
  
  switch(gameState.phase) {
    case 'reveal_initial':
      handleRevealInitial(playerId, action);
      break;
    case 'playing':
      handlePlayingAction(playerId, action);
      break;
  }
}

function handleRevealInitial(playerId, action) {
  if (action.type !== 'reveal') return;
  const { row, col } = action;
  
  if (gameState.revealed[playerId][row][col]) return;
  if (gameState.eliminated[playerId][col]) return;
  if (gameState.initialReveals[playerId] >= 2) return;
  
  gameState.revealed[playerId][row][col] = true;
  gameState.initialReveals[playerId]++;
  
  // Check if all players have revealed 2
  const allDone = gameState.players.every(p => gameState.initialReveals[p.id] >= 2);
  
  if (allDone) {
    // Determine starting player (highest sum of revealed cards)
    let maxSum = -Infinity;
    let startIdx = 0;
    gameState.players.forEach((p, idx) => {
      let sum = 0;
      for (let r = 0; r < ROWS; r++) {
        for (let c = 0; c < COLS; c++) {
          if (gameState.revealed[p.id][r][c]) {
            sum += gameState.hands[p.id][r][c];
          }
        }
      }
      if (sum > maxSum) { maxSum = sum; startIdx = idx; }
    });
    
    gameState.currentPlayerIndex = startIdx;
    gameState.phase = 'playing';
    gameState.turnPhase = 'draw';
    broadcastToast(gameState.players[startIdx].name + ' commence !');
  }
  
  broadcastState();
}

function handlePlayingAction(playerId, action) {
  const currentPlayer = gameState.players[gameState.currentPlayerIndex];
  if (playerId !== currentPlayer.id) return;
  
  switch(action.type) {
    case 'draw_deck':
      if (gameState.turnPhase !== 'draw') return;
      if (gameState.deck.length === 0) reshuffleDeck();
      gameState.drawnCard = gameState.deck.pop();
      gameState.drawnFrom = 'deck';
      gameState.turnPhase = 'drawn_from_pile';
      broadcastState();
      break;
      
    case 'draw_discard':
      if (gameState.turnPhase !== 'draw') return;
      if (gameState.discard.length === 0) return;
      gameState.drawnCard = gameState.discard.pop();
      gameState.drawnFrom = 'discard';
      gameState.turnPhase = 'place_mandatory'; // must replace a card
      broadcastState();
      break;
      
    case 'place_card':
      if (gameState.turnPhase !== 'drawn_from_pile' && gameState.turnPhase !== 'place_mandatory') return;
      const { row, col } = action;
      if (gameState.eliminated[playerId][col]) return;
      
      // Replace card
      const oldCard = gameState.hands[playerId][row][col];
      gameState.hands[playerId][row][col] = gameState.drawnCard;
      gameState.revealed[playerId][row][col] = true;
      gameState.discard.push(oldCard);
      gameState.drawnCard = null;
      
      checkColumnElimination(playerId);
      endTurn();
      break;
      
    case 'discard_drawn':
      if (gameState.turnPhase !== 'drawn_from_pile') return; // only from deck draw
      gameState.discard.push(gameState.drawnCard);
      gameState.drawnCard = null;
      gameState.turnPhase = 'must_reveal'; // must reveal one face-down card
      broadcastState();
      break;
      
    case 'reveal_card':
      if (gameState.turnPhase !== 'must_reveal') return;
      const rr = action.row, rc = action.col;
      if (gameState.revealed[playerId][rr][rc]) return;
      if (gameState.eliminated[playerId][rc]) return;
      gameState.revealed[playerId][rr][rc] = true;
      
      checkColumnElimination(playerId);
      endTurn();
      break;
  }
}

function checkColumnElimination(playerId) {
  for (let c = 0; c < COLS; c++) {
    if (gameState.eliminated[playerId][c]) continue;
    
    let allRevealed = true;
    let allSame = true;
    let val = null;
    
    for (let r = 0; r < ROWS; r++) {
      if (!gameState.revealed[playerId][r][c]) { allRevealed = false; break; }
      if (val === null) val = gameState.hands[playerId][r][c];
      else if (gameState.hands[playerId][r][c] !== val) allSame = false;
    }
    
    if (allRevealed && allSame) {
      gameState.eliminated[playerId][c] = true;
      // Add eliminated cards to discard
      for (let r = 0; r < ROWS; r++) {
        gameState.discard.push(gameState.hands[playerId][r][c]);
      }
      broadcastToast(getPlayerName(playerId) + ' √©limine une colonne de ' + val + ' !');
    }
  }
}

function reshuffleDeck() {
  if (gameState.discard.length <= 1) return;
  const top = gameState.discard.pop();
  gameState.deck = shuffle(gameState.discard);
  gameState.discard = [top];
}

function endTurn() {
  const playerId = gameState.players[gameState.currentPlayerIndex].id;
  
  // Check if this player has all cards revealed (trigger last round)
  if (gameState.lastRoundTriggeredBy === null) {
    const allRevealed = isAllRevealed(playerId);
    if (allRevealed) {
      gameState.lastRoundTriggeredBy = playerId;
      gameState.lastRoundTurnsLeft = gameState.players.length - 1;
      broadcastToast(getPlayerName(playerId) + ' a tout r√©v√©l√© ! Dernier tour !');
    }
  }
  
  if (gameState.lastRoundTriggeredBy !== null) {
    gameState.lastRoundTurnsLeft--;
    if (gameState.lastRoundTurnsLeft <= 0) {
      endRound();
      return;
    }
  }
  
  // Next player
  advancePlayer();
  gameState.turnPhase = 'draw';
  gameState.drawnCard = null;
  gameState.drawnFrom = null;
  broadcastState();
}

function advancePlayer() {
  gameState.currentPlayerIndex = (gameState.currentPlayerIndex + 1) % gameState.players.length;
}

function isAllRevealed(playerId) {
  for (let r = 0; r < ROWS; r++) {
    for (let c = 0; c < COLS; c++) {
      if (gameState.eliminated[playerId][c]) continue;
      if (!gameState.revealed[playerId][r][c]) return false;
    }
  }
  return true;
}

function getPlayerName(id) {
  const p = gameState.players.find(pl => pl.id === id);
  return p ? p.name : '?';
}

// --- END ROUND ---
function endRound() {
  // Reveal all cards
  gameState.players.forEach(p => {
    for (let r = 0; r < ROWS; r++) {
      for (let c = 0; c < COLS; c++) {
        gameState.revealed[p.id][r][c] = true;
      }
    }
  });
  
  // Calculate scores
  const scores = {};
  gameState.players.forEach(p => {
    let sum = 0;
    for (let r = 0; r < ROWS; r++) {
      for (let c = 0; c < COLS; c++) {
        if (!gameState.eliminated[p.id][c]) {
          sum += gameState.hands[p.id][r][c];
        }
      }
    }
    scores[p.id] = sum;
  });
  
  // Check if triggering player has lowest score
  const trigId = gameState.lastRoundTriggeredBy;
  if (trigId) {
    const trigScore = scores[trigId];
    const otherScores = gameState.players.filter(p => p.id !== trigId).map(p => scores[p.id]);
    const minOther = Math.min(...otherScores);
    if (trigScore >= minOther) {
      scores[trigId] *= 2;
      broadcastToast(getPlayerName(trigId) + ' n\'a pas le score le plus bas ! Score doubl√© !');
    }
  }
  
  gameState.roundScores = scores;
  
  // Add to total
  gameState.players.forEach(p => {
    gameState.totalScores[p.id] = (gameState.totalScores[p.id] || 0) + scores[p.id];
  });
  
  // Check game end
  const gameOver = gameState.players.some(p => gameState.totalScores[p.id] >= END_SCORE);
  gameState.phase = gameOver ? 'game_over' : 'round_end';
  
  broadcastState();
}

function nextRound() {
  if (!isHost) return;
  initRound();
}

// --- RENDER ---
function renderFromState() {
  if (!gameState) return;
  
  switch(gameState.phase) {
    case 'lobby':
      showScreen('screen-lobby');
      document.getElementById('lobby-code').textContent = roomCode;
      renderLobby();
      break;
    case 'reveal_initial':
    case 'playing':
      showScreen('screen-game');
      renderGame();
      break;
    case 'round_end':
      showScreen('screen-round-scores');
      renderRoundScores();
      break;
    case 'game_over':
      showScreen('screen-final-scores');
      renderFinalScores();
      break;
  }
}

function renderGame() {
  const pilesArea = document.getElementById('piles-area');
  const playersArea = document.getElementById('players-area');
  const actionBar = document.getElementById('action-bar');
  const statusEl = document.getElementById('game-status');
  const roundEl = document.getElementById('round-info');
  
  roundEl.textContent = 'Manche ' + gameState.round;
  
  const isMyTurn = gameState.phase === 'playing' && 
    gameState.players[gameState.currentPlayerIndex]?.id === myPlayerId;
  
  // Status text
  if (gameState.phase === 'reveal_initial') {
    const myReveals = gameState.initialReveals[myPlayerId] || 0;
    if (myReveals < 2) {
      statusEl.textContent = 'Retournez ' + (2 - myReveals) + ' carte(s)';
    } else {
      statusEl.textContent = 'En attente des autres joueurs...';
    }
  } else if (gameState.phase === 'playing') {
    const cp = gameState.players[gameState.currentPlayerIndex];
    if (isMyTurn) {
      switch(gameState.turnPhase) {
        case 'draw': statusEl.textContent = 'Piochez une carte'; break;
        case 'drawn_from_pile': statusEl.textContent = 'Placez ou d√©faussez (' + gameState.drawnCard + ')'; break;
        case 'place_mandatory': statusEl.textContent = 'Placez la carte (' + gameState.drawnCard + ')'; break;
        case 'must_reveal': statusEl.textContent = 'Retournez une carte face cach√©e'; break;
        default: statusEl.textContent = '√Ä vous de jouer';
      }
    } else {
      statusEl.textContent = 'Tour de ' + cp.name;
    }
    if (gameState.lastRoundTriggeredBy) {
      statusEl.textContent += ' üîî Dernier tour !';
    }
  }
  
  // Piles
  const discardTop = gameState.discard.length > 0 ? gameState.discard[gameState.discard.length - 1] : null;
  const deckCount = gameState.deck ? gameState.deck.length : 0;
  
  let pilesHtml = '<div class="pile">';
  pilesHtml += '<div class="pile-label">Pioche (' + deckCount + ')</div>';
  pilesHtml += '<div class="card face-down" id="pile-deck" onclick="clickDeck()"></div>';
  pilesHtml += '</div>';
  
  pilesHtml += '<div class="pile">';
  pilesHtml += '<div class="pile-label">D√©fausse</div>';
  if (discardTop !== null) {
    pilesHtml += '<div class="card ' + getCardClass(discardTop) + '" id="pile-discard" onclick="clickDiscard()">' + discardTop + '</div>';
  } else {
    pilesHtml += '<div class="card face-down" style="opacity:.3"></div>';
  }
  pilesHtml += '</div>';
  
  // Show drawn card
  if (gameState.drawnCard !== null && isMyTurn) {
    pilesHtml += '<div class="pile">';
    pilesHtml += '<div class="pile-label">En main</div>';
    pilesHtml += '<div class="card ' + getCardClass(gameState.drawnCard) + ' highlight">' + gameState.drawnCard + '</div>';
    pilesHtml += '</div>';
  }
  
  pilesArea.innerHTML = pilesHtml;
  
  // Players - show my cards first, then others
  const orderedPlayers = [...gameState.players].sort((a, b) => {
    if (a.id === myPlayerId) return -1;
    if (b.id === myPlayerId) return 1;
    return 0;
  });
  
  let playersHtml = '';
  orderedPlayers.forEach(p => {
    const isMe = p.id === myPlayerId;
    const isCurrent = gameState.phase === 'playing' && gameState.players[gameState.currentPlayerIndex]?.id === p.id;
    const visibleScore = calcVisibleScore(p.id);
    const totalScore = gameState.totalScores[p.id] || 0;
    
    playersHtml += `<div class="player-zone ${isCurrent ? 'current-turn' : ''} ${isMe ? 'is-me' : ''}">`;
    playersHtml += `<div class="player-header">`;
    playersHtml += `<span class="player-name">${p.name}${isMe ? ' (vous)' : ''}</span>`;
    playersHtml += `<span>`;
    if (isCurrent) playersHtml += `<span class="turn-indicator">‚ñ∂ </span>`;
    playersHtml += `<span class="player-score">Visible: ${visibleScore} | Total: ${totalScore}</span>`;
    playersHtml += `</span></div>`;
    
    playersHtml += '<div class="card-container">';
    for (let r = 0; r < ROWS; r++) {
      playersHtml += '<div class="card-row">';
      for (let c = 0; c < COLS; c++) {
        if (gameState.eliminated[p.id][c]) {
          playersHtml += '<div class="card eliminated"></div>';
        } else if (gameState.revealed[p.id][r][c]) {
          const val = gameState.hands[p.id][r][c];
          playersHtml += `<div class="card ${getCardClass(val)}">${val}</div>`;
        } else {
          const selectable = isCardSelectable(p.id, r, c);
          playersHtml += `<div class="card face-down ${selectable ? 'selectable' : ''}" onclick="clickCard('${p.id}',${r},${c})"></div>`;
        }
      }
      playersHtml += '</div>';
    }
    playersHtml += '</div></div>';
  });
  
  playersArea.innerHTML = playersHtml;
  
  // Also make revealed cards clickable for placement
  // Re-render with onclick for placement
  if (isMyTurn && (gameState.turnPhase === 'drawn_from_pile' || gameState.turnPhase === 'place_mandatory')) {
    // Add click handlers to all my non-eliminated cards
    playersArea.querySelectorAll('.player-zone.is-me .card:not(.eliminated)').forEach(cardEl => {
      if (!cardEl.classList.contains('face-down')) {
        // It's a revealed card, make it clickable for replacement
        const row = cardEl.closest('.card-row');
        const container = cardEl.closest('.card-container');
        if (row && container) {
          const rows = Array.from(container.children);
          const r = rows.indexOf(row);
          const cols = Array.from(row.children);
          const c = cols.indexOf(cardEl);
          if (r >= 0 && c >= 0 && !gameState.eliminated[myPlayerId][c]) {
            cardEl.style.cursor = 'pointer';
            cardEl.classList.add('selectable');
            cardEl.onclick = () => clickCard(myPlayerId, r, c);
          }
        }
      }
    });
  }
  
  // Action bar
  if (isMyTurn && gameState.turnPhase === 'drawn_from_pile') {
    actionBar.style.display = '';
    actionBar.innerHTML = '<button class="danger" onclick="discardDrawn()">D√©fausser le ' + gameState.drawnCard + '</button>';
  } else {
    actionBar.style.display = 'none';
    actionBar.innerHTML = '';
  }
}

function isCardSelectable(playerId, row, col) {
  if (gameState.eliminated[playerId][col]) return false;
  const isMe = playerId === myPlayerId;
  
  if (gameState.phase === 'reveal_initial') {
    return isMe && !gameState.revealed[playerId][row][col] && (gameState.initialReveals[playerId] || 0) < 2;
  }
  
  if (gameState.phase === 'playing') {
    const isMyTurn = gameState.players[gameState.currentPlayerIndex]?.id === myPlayerId;
    if (!isMe || !isMyTurn) return false;
    
    if (gameState.turnPhase === 'must_reveal') {
      return !gameState.revealed[playerId][row][col];
    }
    if (gameState.turnPhase === 'drawn_from_pile' || gameState.turnPhase === 'place_mandatory') {
      return true; // can place on any non-eliminated card
    }
  }
  return false;
}

function getCardClass(val) {
  if (val <= -2) return 'val-neg2';
  if (val === -1) return 'val-neg1';
  if (val === 0) return 'val-0';
  if (val <= 4) return 'val-' + val;
  if (val <= 8) return 'val-' + val;
  return 'val-' + val;
}

function calcVisibleScore(playerId) {
  let sum = 0;
  for (let r = 0; r < ROWS; r++) {
    for (let c = 0; c < COLS; c++) {
      if (gameState.eliminated[playerId][c]) continue;
      if (gameState.revealed[playerId][r][c]) {
        sum += gameState.hands[playerId][r][c];
      }
    }
  }
  return sum;
}

// --- CLICK HANDLERS ---
function clickDeck() {
  const isMyTurn = gameState.phase === 'playing' && 
    gameState.players[gameState.currentPlayerIndex]?.id === myPlayerId;
  if (!isMyTurn || gameState.turnPhase !== 'draw') return;
  performAction({ type: 'draw_deck' });
}

function clickDiscard() {
  const isMyTurn = gameState.phase === 'playing' && 
    gameState.players[gameState.currentPlayerIndex]?.id === myPlayerId;
  if (!isMyTurn || gameState.turnPhase !== 'draw') return;
  performAction({ type: 'draw_discard' });
}

function clickCard(playerId, row, col) {
  if (gameState.phase === 'reveal_initial') {
    if (playerId !== myPlayerId) return;
    performAction({ type: 'reveal', row, col });
    return;
  }
  
  if (gameState.phase === 'playing') {
    const isMyTurn = gameState.players[gameState.currentPlayerIndex]?.id === myPlayerId;
    if (!isMyTurn || playerId !== myPlayerId) return;
    
    if (gameState.turnPhase === 'must_reveal') {
      if (!gameState.revealed[playerId][row][col]) {
        performAction({ type: 'reveal_card', row, col });
      }
      return;
    }
    
    if (gameState.turnPhase === 'drawn_from_pile' || gameState.turnPhase === 'place_mandatory') {
      if (!gameState.eliminated[playerId][col]) {
        performAction({ type: 'place_card', row, col });
      }
      return;
    }
  }
}

function discardDrawn() {
  performAction({ type: 'discard_drawn' });
}

// --- SCORES ---
function renderRoundScores() {
  const table = document.getElementById('round-scores-table');
  let html = '<thead><tr><th>Joueur</th><th>Manche</th><th>Total</th></tr></thead><tbody>';
  
  const sorted = [...gameState.players].sort((a, b) => 
    (gameState.totalScores[a.id] || 0) - (gameState.totalScores[b.id] || 0)
  );
  
  sorted.forEach((p, i) => {
    const rs = gameState.roundScores[p.id] || 0;
    const ts = gameState.totalScores[p.id] || 0;
    const isTriggerer = p.id === gameState.lastRoundTriggeredBy;
    html += `<tr${i === 0 ? ' class="winner"' : ''}>`;
    html += `<td>${p.name}${isTriggerer ? ' üîî' : ''}${p.id === myPlayerId ? ' (vous)' : ''}</td>`;
    html += `<td>${rs > 0 ? '+' : ''}${rs}</td>`;
    html += `<td class="total">${ts}</td></tr>`;
  });
  
  html += '</tbody>';
  table.innerHTML = html;
  
  document.getElementById('next-round-btn').style.display = isHost ? '' : 'none';
}

function renderFinalScores() {
  const table = document.getElementById('final-scores-table');
  let html = '<thead><tr><th>üèÜ</th><th>Joueur</th><th>Score</th></tr></thead><tbody>';
  
  const sorted = [...gameState.players].sort((a, b) => 
    (gameState.totalScores[a.id] || 0) - (gameState.totalScores[b.id] || 0)
  );
  
  sorted.forEach((p, i) => {
    const ts = gameState.totalScores[p.id] || 0;
    const medal = i === 0 ? 'ü•á' : i === 1 ? 'ü•à' : i === 2 ? 'ü•â' : (i + 1);
    html += `<tr${i === 0 ? ' class="winner"' : ''}>`;
    html += `<td>${medal}</td>`;
    html += `<td>${p.name}${p.id === myPlayerId ? ' (vous)' : ''}</td>`;
    html += `<td class="total">${ts}</td></tr>`;
  });
  
  html += '</tbody>';
  table.innerHTML = html;
}

// --- RULES MODAL ---
function showRules() {
  showModal('R√®gles Skyjo', `
    <div style="text-align:left;font-size:.85em;max-height:60vh;overflow-y:auto;line-height:1.6">
    <b>But :</b> Avoir le score le plus bas √† la fin de la partie.<br><br>
    <b>D√©but :</b> Chaque joueur retourne 2 cartes. Le joueur avec la plus haute somme commence.<br><br>
    <b>Tour :</b><br>
    ‚Ä¢ Piochez depuis la <b>pioche</b> ou la <b>d√©fausse</b><br>
    ‚Ä¢ Si pioche : placez la carte sur votre grille OU d√©faussez-la et retournez une carte face cach√©e<br>
    ‚Ä¢ Si d√©fausse : vous DEVEZ placer la carte sur votre grille<br><br>
    <b>Colonnes :</b> 3 cartes identiques dans une colonne ‚Üí √©limin√©es !<br><br>
    <b>Fin de manche :</b> Quand un joueur a toutes ses cartes visibles, chaque autre joueur joue un dernier tour.<br><br>
    <b>Score doubl√© :</b> Si le joueur qui termine n'a pas le score le plus bas, son score est doubl√© !<br><br>
    <b>Fin de partie :</b> Quand un joueur atteint 100 points. Le joueur avec le score le plus bas gagne !<br><br>
    <b>Valeurs :</b> -2 (√ó5), -1 (√ó10), 0 (√ó15), 1-12 (√ó10 chaque)
    </div>
  `, [{ text: 'Compris !', action: 'closeModal()' }]);
}

// --- MODAL ---
function showModal(title, text, buttons) {
  document.getElementById('modal-title').textContent = title;
  document.getElementById('modal-text').innerHTML = text;
  const btnContainer = document.getElementById('modal-buttons');
  btnContainer.innerHTML = buttons.map(b => 
    `<button onclick="${b.action}">${b.text}</button>`
  ).join('');
  document.getElementById('modal').classList.add('active');
}

function closeModal() {
  document.getElementById('modal').classList.remove('active');
}

// --- TOAST ---
function toast(msg) {
  const el = document.getElementById('toast');
  el.textContent = msg;
  el.classList.add('show');
  setTimeout(() => el.classList.remove('show'), 2500);
}

// --- URL PARAMS (auto-join) ---
window.addEventListener('load', () => {
  const params = new URLSearchParams(window.location.search);
  const room = params.get('room');
  if (room) {
    document.getElementById('room-input').value = room;
    showJoinScreen();
  }
});
</script>
</body>
</html>
