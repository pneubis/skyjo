<!DOCTYPE html>
<html lang="fr">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no, maximum-scale=1.0">
<title>Skyjo Multijoueur</title>
<link rel="icon" href="https://public-frontend-cos.metadl.com/mgx/img/favicon_atoms.ico" type="image/x-icon">
<script src="https://cdn.jsdelivr.net/npm/davidshimjs-qrcodejs@0.0.2/qrcode.min.js"></script>
<style>
*{margin:0;padding:0;box-sizing:border-box;-webkit-tap-highlight-color:transparent}
body{font-family:'Segoe UI',system-ui,-apple-system,sans-serif;background:#1a1a2e;color:#fff;min-height:100vh;overflow-x:hidden;user-select:none}
.screen{display:none;flex-direction:column;align-items:center;justify-content:center;min-height:100vh;padding:16px}
.screen.active{display:flex}
h1{font-size:2.2em;font-weight:700;margin-bottom:8px;background:linear-gradient(135deg,#9b59b6,#3498db);-webkit-background-clip:text;-webkit-text-fill-color:transparent;background-clip:text}
h2{font-size:1.4em;font-weight:600;margin-bottom:16px;color:#ccc}
.subtitle{color:#888;font-size:0.9em;margin-bottom:24px}
button{background:linear-gradient(135deg,#9b59b6,#8e44ad);color:#fff;border:none;padding:14px 32px;border-radius:12px;font-size:1em;font-weight:600;cursor:pointer;transition:all .2s;touch-action:manipulation;min-height:48px}
button:hover{transform:translateY(-2px);box-shadow:0 4px 15px rgba(155,89,182,.4)}
button:active{transform:translateY(0)}
button.secondary{background:rgba(255,255,255,.1);backdrop-filter:blur(10px)}
button.secondary:hover{background:rgba(255,255,255,.2);box-shadow:none}
button.danger{background:linear-gradient(135deg,#e74c3c,#c0392b)}
input{background:rgba(255,255,255,.1);border:2px solid rgba(255,255,255,.15);color:#fff;padding:14px 18px;border-radius:12px;font-size:1em;width:100%;max-width:320px;outline:none;transition:border-color .2s}
input:focus{border-color:#9b59b6}
input::placeholder{color:#666}
.btn-group{display:flex;gap:12px;flex-wrap:wrap;justify-content:center;margin-top:16px}
.card-container{display:flex;flex-direction:column;gap:4px;margin:8px}
.card-row{display:flex;gap:4px;justify-content:center}

/* Cards */
.card{width:52px;height:72px;border-radius:8px;display:flex;align-items:center;justify-content:center;font-size:1.2em;font-weight:700;cursor:pointer;transition:all .2s;position:relative;border:2px solid rgba(255,255,255,.1)}
.card:active{transform:scale(.95)}
.card.face-down{background:linear-gradient(135deg,#4a4a6a,#3a3a5a);color:transparent;cursor:pointer}
.card.face-down::after{content:'?';color:#666;font-size:1.4em;position:absolute}
.card.eliminated{opacity:0;pointer-events:none;transform:scale(0)}
.card.selectable{animation:pulse 1s infinite;box-shadow:0 0 12px rgba(155,89,182,.6)}
.card.highlight{box-shadow:0 0 15px rgba(255,255,255,.5)}
@keyframes pulse{0%,100%{box-shadow:0 0 8px rgba(155,89,182,.4)}50%{box-shadow:0 0 18px rgba(155,89,182,.8)}}

.card.val-neg2{background:linear-gradient(135deg,#27ae60,#2ecc71);color:#fff}
.card.val-neg1{background:linear-gradient(135deg,#2ecc71,#58d68d);color:#fff}
.card.val-0{background:linear-gradient(135deg,#2980b9,#3498db);color:#fff}
.card.val-1,.card.val-2,.card.val-3,.card.val-4{background:linear-gradient(135deg,#f39c12,#f1c40f);color:#333}
.card.val-5,.card.val-6,.card.val-7,.card.val-8{background:linear-gradient(135deg,#d35400,#e67e22);color:#fff}
.card.val-9,.card.val-10,.card.val-11,.card.val-12{background:linear-gradient(135deg,#c0392b,#e74c3c);color:#fff}

/* Piles */
.piles{display:flex;gap:20px;align-items:center;justify-content:center;margin:12px 0}
.pile{display:flex;flex-direction:column;align-items:center;gap:6px}
.pile-label{font-size:.75em;color:#888;text-transform:uppercase;letter-spacing:1px}
.pile .card{width:58px;height:80px;font-size:1.4em}

/* Player areas */
.players-area{width:100%;max-width:700px;display:flex;flex-direction:column;gap:12px;padding:8px}
.player-zone{background:rgba(255,255,255,.05);border-radius:12px;padding:10px;border:2px solid transparent;transition:border-color .3s}
.player-zone.current-turn{border-color:#9b59b6}
.player-zone.is-me{border-color:rgba(52,152,219,.5)}
/*.player-zone.is-me.current-turn {border-color:#9b59b6;box-shadow:0 0 20px rgba(155,89,182,.3)} */

/* Fond prononc√© quand c'est le tour du joueur local */
.player-zone.is-me.current-turn {
  border-color: #9b59b6;
  box-shadow: 0 0 20px rgba(155,89,182,.3);
  background: rgba(155,89,182,.18);          /* ‚Üê NOUVEAU : fond violet plus marqu√© */
  animation: myTurnPulse 2s ease-in-out infinite;  /* ‚Üê NOUVEAU : l√©g√®re animation */
}
@keyframes myTurnPulse {
  0%, 100% { background: rgba(155,89,182,.12); box-shadow: 0 0 20px rgba(155,89,182,.3); }
  50%       { background: rgba(155,89,182,.28); box-shadow: 0 0 35px rgba(155,89,182,.6); }
}

.player-header{display:flex;justify-content:space-between;align-items:center;margin-bottom:6px;padding:0 4px}
.player-name::after {font-weight:600;font-size:.9em} 
.player-score{font-size:.85em;color:#888}
.player-badge{font-size:.7em;padding:2px 8px;border-radius:20px;background:rgba(155,89,182,.3);color:#bb86fc}
.turn-indicator{font-size:.7em;color:#f1c40f;font-weight:600}

/* Lobby */
.lobby-box{background:rgba(255,255,255,.05);border-radius:16px;padding:24px;max-width:400px;width:100%;text-align:center}
.lobby-players{list-style:none;margin:16px 0;text-align:left}
.lobby-players li{padding:10px 16px;background:rgba(255,255,255,.05);border-radius:8px;margin-bottom:6px;display:flex;justify-content:space-between;align-items:center}
.lobby-players li .host-badge{font-size:.7em;background:#9b59b6;padding:2px 8px;border-radius:10px}
#qr-container{margin:16px auto;border-radius:12px;background:#fff;padding:8px;display:inline-block}
#qr-container img{display:block;border-radius:4px}
.room-code{font-family:monospace;font-size:1.8em;letter-spacing:4px;color:#bb86fc;margin:8px 0}
.copy-btn{font-size:.8em;padding:8px 16px;margin-top:4px}

/* Game header */
.game-header{width:100%;max-width:700px;display:flex;justify-content:space-between;align-items:center;padding:8px 12px;background:rgba(255,255,255,.05);border-radius:12px;margin-bottom:8px}
.game-status{font-size:.85em;color:#ccc;text-align:center;flex:1}
.round-info{font-size:.75em;color:#888}

/* Action bar */
.action-bar{position:fixed;bottom:0;left:0;right:0;background:rgba(26,26,46,.95);backdrop-filter:blur(10px);padding:12px 16px;display:flex;justify-content:center;gap:10px;border-top:1px solid rgba(255,255,255,.1);z-index:100}
.action-bar button{padding:10px 20px;font-size:.85em}

/* Scores screen */
.scores-table{width:100%;max-width:500px;border-collapse:collapse;margin:16px 0}
.scores-table th,.scores-table td{padding:12px 16px;text-align:center;border-bottom:1px solid rgba(255,255,255,.1)}
.scores-table th{color:#888;font-weight:600;font-size:.85em;text-transform:uppercase}
.scores-table tr.winner{background:rgba(46,204,113,.15)}
.scores-table td.total{font-weight:700;color:#bb86fc}

/* Winner zoom animation */
.winner-name{display:inline-block;animation:winnerZoom 1.5s ease-in-out infinite alternate;font-size:1.3em;font-weight:800;color:#f1c40f}
@keyframes winnerZoom{0%{transform:scale(1);text-shadow:0 0 5px rgba(241,196,15,.3)}100%{transform:scale(1.15);text-shadow:0 0 20px rgba(241,196,15,.6)}}

/* Toast */
.toast{position:fixed;top:20px;left:50%;transform:translateX(-50%);background:rgba(155,89,182,.9);color:#fff;padding:12px 24px;border-radius:12px;font-size:.9em;z-index:200;opacity:0;transition:opacity .3s;pointer-events:none}
.toast.show{opacity:1}

/* Modal */
.modal-overlay{position:fixed;inset:0;background:rgba(0,0,0,.7);display:none;align-items:center;justify-content:center;z-index:300;padding:16px}
.modal-overlay.active{display:flex}
.modal{background:#2a2a4a;border-radius:16px;padding:24px;max-width:400px;width:100%;text-align:center}
.modal h3{margin-bottom:12px;font-size:1.2em}
.modal p{color:#aaa;margin-bottom:16px;font-size:.9em}

/* Scrollable game */
.game-content{width:100%;overflow-y:auto;padding-bottom:80px;display:flex;flex-direction:column;align-items:center}

/* Boom animation for column elimination */
.boom-overlay{position:fixed;inset:0;pointer-events:none;z-index:150}
.boom-particle{position:absolute;border-radius:50%;pointer-events:none;animation:boomExplode .8s ease-out forwards}
@keyframes boomExplode{
  0%{opacity:1;transform:translate(0,0) scale(1)}
  100%{opacity:0;transform:translate(var(--dx),var(--dy)) scale(0)}
}
.boom-text{position:fixed;top:50%;left:50%;transform:translate(-50%,-50%) scale(0);font-size:3em;font-weight:900;color:#f1c40f;text-shadow:0 0 30px rgba(241,196,15,.8),0 0 60px rgba(241,196,15,.4);z-index:160;pointer-events:none;animation:boomTextAnim .8s ease-out forwards}
@keyframes boomTextAnim{
  0%{transform:translate(-50%,-50%) scale(0);opacity:1}
  50%{transform:translate(-50%,-50%) scale(1.3);opacity:1}
  100%{transform:translate(-50%,-50%) scale(1);opacity:0}
}

/* Round reveal screen */
.reveal-summary{text-align:center;max-width:500px;width:100%}
.reveal-summary .player-result{background:rgba(255,255,255,.05);border-radius:12px;padding:12px 16px;margin:8px 0;display:flex;justify-content:space-between;align-items:center}
.reveal-summary .player-result .score-val{font-size:1.3em;font-weight:700;color:#bb86fc}
.reveal-summary .player-result.best{border:2px solid #2ecc71;background:rgba(46,204,113,.1)}

/* Leaderboard */
.leaderboard-box{background:rgba(255,255,255,.05);border-radius:16px;padding:20px;max-width:400px;width:100%;margin-top:16px}
.leaderboard-box h3{font-size:1em;color:#888;margin-bottom:12px;text-transform:uppercase;letter-spacing:1px}
.lb-row{display:flex;justify-content:space-between;align-items:center;padding:8px 12px;border-bottom:1px solid rgba(255,255,255,.05)}
.lb-row:last-child{border-bottom:none}
.lb-rank{width:30px;font-weight:700;color:#f1c40f}
.lb-name{flex:1;font-weight:500}
.lb-wins{color:#2ecc71;font-weight:700}
.lb-games{color:#888;font-size:.85em;margin-left:8px}

/* Responsive */
@media(max-width:400px){
  .card{width:44px;height:62px;font-size:1em;border-radius:6px}
  .pile .card{width:50px;height:70px;font-size:1.2em}
  h1{font-size:1.8em}
}

/* Reconnect overlay */
#reconnect-overlay{position:fixed;inset:0;background:rgba(0,0,0,.85);z-index:1000;display:none;flex-direction:column;align-items:center;justify-content:center;gap:16px;text-align:center;padding:24px}
#reconnect-overlay.show{display:flex}
#reconnect-overlay h3{color:#f1c40f;font-size:1.3em}
#reconnect-overlay p{color:#aaa;font-size:.9em}
.reconnect-spinner{width:48px;height:48px;border:4px solid rgba(155,89,182,.3);border-top-color:#9b59b6;border-radius:50%;animation:spin 1s linear infinite}
@keyframes spin{to{transform:rotate(360deg)}}

/* Fullscreen button */
#fullscreen-btn{position:fixed;top:10px;right:10px;z-index:500;background:rgba(155,89,182,.7);border:none;color:#fff;border-radius:10px;padding:8px 12px;font-size:1.2em;cursor:pointer;backdrop-filter:blur(10px);min-height:42px;min-width:42px;line-height:1;transition:background .2s;box-shadow:0 2px 8px rgba(0,0,0,.3)}
#fullscreen-btn:hover,#fullscreen-btn:active{background:rgba(155,89,182,1)}

/* Fullscreen tip banner (iOS) */
#fs-tip {
  position: fixed; bottom: 70px; left: 50%; transform: translateX(-50%);
  background: rgba(26,26,46,.97); color: #fff;
  padding: 14px 20px; border-radius: 14px; font-size: .82em;
  z-index: 600; text-align: center; max-width: 300px; display: none;
  border: 1px solid rgba(155,89,182,.4);
  box-shadow: 0 4px 20px rgba(0,0,0,.5);
}
#fs-tip button { padding: 8px 16px; font-size: .85em; margin-top: 10px; }
</style>
</head>
<body>

<!-- TOAST -->
<div class="toast" id="toast"></div>

<!-- FULLSCREEN BUTTON -->
<button id="fullscreen-btn" onclick="toggleFullscreen()" title="Plein √©cran">‚õ∂</button>

<!-- iOS FULLSCREEN TIP -->
<div id="fs-tip">
  <div>üì± <strong>iOS Safari</strong> ne supporte pas le plein √©cran natif.</div>
  <div style="margin-top:6px;color:#aaa">
    Pour jouer en plein √©cran :<br>
    Appuyez sur <strong>‚ñ°‚Üë</strong> puis <em>"Sur l'√©cran d'accueil"</em>
  </div>
  <div style="margin-top:10px;display:flex;justify-content:center;gap:8px">
    <button onclick="closeFsTip()">OK compris</button>
  </div>
</div>

<!-- BOOM OVERLAY -->
<div class="boom-overlay" id="boom-overlay"></div>

<!-- MODAL -->
<div class="modal-overlay" id="modal">
  <div class="modal">
    <h3 id="modal-title"></h3>
    <p id="modal-text"></p>
    <div class="btn-group" id="modal-buttons"></div>
  </div>
</div>

<!-- SCREEN: MENU -->
<div class="screen active" id="screen-menu">
  <h1>SKYJO</h1>
  <p class="subtitle">Jeu de cartes multijoueur V1.1.1</p>
  <div style="margin:12px 0;width:100%;max-width:320px">
    <input type="text" id="player-name" placeholder="Votre pseudo" maxlength="12" autocomplete="off">
  </div>
  <div class="btn-group" style="margin-top:8px">
    <button onclick="createGame()">Cr√©er une partie</button>
    <button class="secondary" onclick="showJoinScreen()">Rejoindre</button>
  </div>
  <!-- Persistent Leaderboard -->
  <div class="leaderboard-box" id="menu-leaderboard" style="margin-top:24px"></div>
</div>

<!-- SCREEN: JOIN -->
<div class="screen" id="screen-join">
  <h1>SKYJO</h1>
  <h2>Rejoindre une partie</h2>
  <div style="width:100%;max-width:320px">
    <input type="text" id="room-input" placeholder="Code de la salle" maxlength="6" autocomplete="off" style="text-transform:uppercase;text-align:center;font-size:1.4em;letter-spacing:4px">
  </div>
  <div class="btn-group">
    <button onclick="joinGame()">Rejoindre</button>
    <button class="secondary" onclick="showScreen('screen-menu')">Retour</button>
  </div>
</div>

<!-- SCREEN: LOBBY -->
<div class="screen" id="screen-lobby">
  <div class="lobby-box">
    <h2>Salle d'attente</h2>
    <p class="subtitle">Partagez le code ou le QR code</p>
    <div class="room-code" id="lobby-code"></div>
    <button class="copy-btn secondary" onclick="copyCode()">üìã Copier le lien</button>
    <div id="qr-container"></div>
    <ul class="lobby-players" id="lobby-players"></ul>
    <div class="btn-group">
      <button id="start-btn" onclick="startGame()" style="display:none">Lancer la partie</button>
      <button class="danger" onclick="leaveLobby()">Quitter</button>
    </div>
  </div>
</div>

<!-- SCREEN: GAME -->
<div class="screen" id="screen-game" style="justify-content:flex-start;padding-top:8px">
  <div class="game-header">
    <div class="round-info" id="round-info">Manche 1</div>
    <div class="game-status" id="game-status">En attente...</div>
    <button class="secondary" style="padding:6px 12px;font-size:.75em" onclick="showRules()">?</button>
  </div>
  <div class="game-content" id="game-content">
    <div class="piles" id="piles-area"></div>
    <div class="players-area" id="players-area"></div>
  </div>
  <div class="action-bar" id="action-bar" style="display:none"></div>
</div>

<!-- SCREEN: ROUND REVEAL (show all grids + scores before table) -->
<div class="screen" id="screen-round-reveal">
  <h2>üìä Fin de la manche</h2>
  <p class="subtitle" id="reveal-subtitle"></p>
  <div class="reveal-summary" id="reveal-summary"></div>
  <div class="btn-group" style="margin-top:20px">
    <button onclick="showRoundScoreTable()">Voir le tableau des scores</button>
  </div>
</div>

<!-- SCREEN: ROUND SCORES -->
<div class="screen" id="screen-round-scores">
  <h2>Tableau des scores</h2>
  <table class="scores-table" id="round-scores-table"></table>
  <div class="btn-group">
    <button id="next-round-btn" onclick="nextRound()">Manche suivante</button>
  </div>
</div>

<!-- SCREEN: FINAL SCORES -->
<div class="screen" id="screen-final-scores">
  <h1>üèÜ Fin de partie</h1>
  <div id="final-winner-banner" style="margin:16px 0"></div>
  <table class="scores-table" id="final-scores-table"></table>
  <div class="leaderboard-box" id="final-leaderboard" style="margin-top:16px"></div>
  <div class="btn-group">
    <button onclick="backToMenu()">Menu principal</button>
  </div>
</div>

<script type="module">
// ============================================================
// SKYJO MULTIPLAYER - Trystero (BitTorrent P2P, z√©ro serveur)
// ============================================================
import { joinRoom, selfId } from 'https://esm.run/trystero/torrent';

// --- CONSTANTS ---
const CARD_COUNTS = {'-2':5,'-1':10,'0':15,'1':10,'2':10,'3':10,'4':10,'5':10,'6':10,'7':10,'8':10,'9':10,'10':10,'11':10,'12':10};
const ROWS = 3, COLS = 4;
const MAX_PLAYERS = 8;
const END_SCORE = 100;
const APP_ID = 'skyjo-multiplayer-v2';

// --- STATE ---
let trysteroRoom = null;
let isHost = false;
let myName = '';
let roomCode = '';
let gameState = null;
let myPlayerId = selfId; // ID unique stable (g√©n√©r√© par Trystero)
let currentScreen = 'screen-menu';

// Actions Trystero (initialis√©es √† la connexion)
let sendMsg = null;
let getMsg = null;

// Peers connect√©s (pour l'h√¥te : peerId ‚Üí true)
let connectedPeers = new Set();

// Mapping peerId ‚Üí playerId pour l'h√¥te
let peerToPlayer = {};

// --- PERSISTENT LEADERBOARD ---
function getLeaderboard() {
  try { return JSON.parse(localStorage.getItem('skyjo_leaderboard') || '{}'); } catch(e) { return {}; }
}
function saveLeaderboard(lb) {
  try { localStorage.setItem('skyjo_leaderboard', JSON.stringify(lb)); } catch(e) {}
}
function updateLeaderboard(playerName, won) {
  const lb = getLeaderboard();
  if (!lb[playerName]) lb[playerName] = { wins: 0, games: 0 };
  lb[playerName].games++;
  if (won) lb[playerName].wins++;
  saveLeaderboard(lb);
}
function renderLeaderboard(containerId) {
  const lb = getLeaderboard();
  const container = document.getElementById(containerId);
  if (!container) return;
  const entries = Object.entries(lb).sort((a, b) => b[1].wins - a[1].wins || a[1].games - b[1].games);
  if (entries.length === 0) {
    container.innerHTML = '<h3>üèÜ Classement</h3><p style="color:#666;font-size:.85em">Aucune partie termin√©e</p>';
    return;
  }
  let html = '<h3>üèÜ Classement persistant</h3>';
  entries.slice(0, 10).forEach(([name, data], i) => {
    const rank = i === 0 ? 'ü•á' : i === 1 ? 'ü•à' : i === 2 ? 'ü•â' : (i + 1);
    html += `<div class="lb-row"><span class="lb-rank">${rank}</span><span class="lb-name">${name}</span><span class="lb-wins">${data.wins}W</span><span class="lb-games">${data.games}G</span></div>`;
  });
  container.innerHTML = html;
}

// --- BOOM ANIMATION ---
function triggerBoom() {
  const overlay = document.getElementById('boom-overlay');
  overlay.innerHTML = '';
  const colors = ['#f1c40f','#e74c3c','#e67e22','#9b59b6','#2ecc71','#3498db'];
  for (let i = 0; i < 30; i++) {
    const p = document.createElement('div');
    p.className = 'boom-particle';
    const size = 6 + Math.random() * 12;
    const angle = Math.random() * Math.PI * 2;
    const dist = 80 + Math.random() * 200;
    p.style.cssText = `width:${size}px;height:${size}px;background:${colors[Math.floor(Math.random()*colors.length)]};left:50%;top:50%;--dx:${Math.cos(angle)*dist}px;--dy:${Math.sin(angle)*dist}px;`;
    overlay.appendChild(p);
  }
  const txt = document.createElement('div');
  txt.className = 'boom-text';
  txt.textContent = 'üí• BOOM!';
  overlay.appendChild(txt);
  setTimeout(() => { overlay.innerHTML = ''; }, 1000);
}

// --- FULLSCREEN ---
const isIOS = /iPad|iPhone|iPod/.test(navigator.userAgent) && !window.MSStream;
const isAndroid = /Android/.test(navigator.userAgent);

function toggleFullscreen() {
  const btn = document.getElementById('fullscreen-btn');
  if (isIOS) {
    const tip = document.getElementById('fs-tip');
    tip.style.display = tip.style.display === 'block' ? 'none' : 'block';
    return;
  }
  const isFs = !!(document.fullscreenElement || document.webkitFullscreenElement);
  if (!isFs) {
    const el = document.documentElement;
    const req = el.requestFullscreen || el.webkitRequestFullscreen;
    if (req) req.call(el).then(() => { btn.textContent = '‚úï'; }).catch(() => toast('Plein √©cran non disponible'));
  } else {
    const exit = document.exitFullscreen || document.webkitExitFullscreen;
    if (exit) exit.call(document);
    btn.textContent = '‚õ∂';
  }
}
function closeFsTip() { document.getElementById('fs-tip').style.display = 'none'; }

['fullscreenchange','webkitfullscreenchange'].forEach(ev => {
  document.addEventListener(ev, () => {
    const btn = document.getElementById('fullscreen-btn');
    const isFs = !!(document.fullscreenElement || document.webkitFullscreenElement);
    btn.textContent = isFs ? '‚úï' : '‚õ∂';
  });
});
window.addEventListener('load', () => {
  if (isIOS) {
    const btn = document.getElementById('fullscreen-btn');
    btn.textContent = 'üì±';
    if (!localStorage.getItem('skyjo_fs_tip_shown')) {
      setTimeout(() => { document.getElementById('fs-tip').style.display = 'block'; localStorage.setItem('skyjo_fs_tip_shown','1'); }, 1500);
    }
  }
});

// --- TRYSTERO SETUP ---
function generateRoomCode() {
  const chars = 'ABCDEFGHJKLMNPQRSTUVWXYZ23456789';
  let code = '';
  for (let i = 0; i < 5; i++) code += chars[Math.floor(Math.random() * chars.length)];
  return code;
}

function setupRoom(room) {
  trysteroRoom = room;
  connectedPeers = new Set();

  // Cr√©er une seule action bidirectionnelle pour tous les messages
  [sendMsg, getMsg] = room.makeAction('msg');

  getMsg((data, peerId) => {
    if (isHost) {
      handleHostMessage(peerId, data);
    } else {
      handleClientMessage(data);
    }
  });

  room.onPeerJoin((peerId) => {
    connectedPeers.add(peerId);
    if (!isHost) {
      // Client : signaler notre pr√©sence √† l'h√¥te
      sendMsg({ type: 'join', name: myName, id: myPlayerId }, peerId);
    }
  });

  room.onPeerLeave((peerId) => {
    connectedPeers.delete(peerId);
    if (isHost) {
      const playerId = peerToPlayer[peerId] || peerId;
      handleDisconnect(playerId, peerId);
    } else {
      // On a perdu l'h√¥te
      if (gameState) {
        toast('D√©connect√© de l\'h√¥te');
      }
    }
  });
}

// --- MENU ---
function getName() {
  let name = document.getElementById('player-name').value.trim();
  if (!name) name = 'Joueur' + Math.floor(Math.random() * 999);
  return name;
}
function showScreen(id) {
  document.querySelectorAll('.screen').forEach(s => s.classList.remove('active'));
  document.getElementById(id).classList.add('active');
  currentScreen = id;
  if (id === 'screen-menu') renderLeaderboard('menu-leaderboard');
}
function showJoinScreen() {
  myName = getName();
  showScreen('screen-join');
  document.getElementById('room-input').focus();
}

// --- CREATE GAME (HOST) ---
async function createGame() {
  myName = getName();
  roomCode = generateRoomCode();
  isHost = true;
  peerToPlayer = {};

  // Quitter la room pr√©c√©dente si elle existe
  if (trysteroRoom) { try { trysteroRoom.leave(); } catch(e) {} trysteroRoom = null; }

  toast('Cr√©ation de la salle...');

  try {
    const room = joinRoom({ appId: APP_ID }, 'skyjo-' + roomCode);
    setupRoom(room);
  } catch(e) {
    toast('Erreur lors de la cr√©ation : ' + e.message);
    isHost = false;
    return;
  }

  gameState = {
    phase: 'lobby',
    players: [{ id: myPlayerId, name: myName, isHost: true }],
    round: 0,
    totalScores: { [myPlayerId]: 0 }
  };

  showLobby();
  toast('Salle cr√©√©e ! En attente de joueurs...');
}

// --- JOIN GAME (CLIENT) ---
async function joinGame() {
  myName = getName();
  const code = document.getElementById('room-input').value.trim().toUpperCase();
  if (!code) { toast('Entrez un code'); return; }
  roomCode = code;
  isHost = false;

  if (trysteroRoom) { try { trysteroRoom.leave(); } catch(e) {} trysteroRoom = null; }

  toast('Connexion √† la salle...');

  try {
    const room = joinRoom({ appId: APP_ID }, 'skyjo-' + roomCode);
    setupRoom(room);
  } catch(e) {
    toast('Erreur de connexion : ' + e.message);
    return;
  }

  // Afficher le lobby imm√©diatement (on attend les peers)
  showScreen('screen-lobby');
  document.getElementById('lobby-code').textContent = roomCode;
  generateQR();

  // Si personne ne rejoint en 15s, c'est que le code est mauvais
  setTimeout(() => {
    if (connectedPeers.size === 0 && currentScreen === 'screen-lobby' && !isHost) {
      toast('Aucun h√¥te trouv√©. V√©rifiez le code.');
    }
  }, 15000);
}

// --- HOST MESSAGE HANDLING ---
function handleHostMessage(peerId, data) {
  if (!gameState) return;

  switch(data.type) {
    case 'join':
      if (gameState.phase !== 'lobby') {
        sendMsg({ type: 'error', msg: 'Partie d√©j√† en cours' }, peerId);
        return;
      }
      if (gameState.players.length >= MAX_PLAYERS) {
        sendMsg({ type: 'error', msg: 'Salle pleine' }, peerId);
        return;
      }
      // Associer peerId ‚Üí playerId
      peerToPlayer[peerId] = data.id;
      // Ajouter le joueur
      if (!gameState.players.find(p => p.id === data.id)) {
        gameState.players.push({ id: data.id, name: data.name, isHost: false });
        gameState.totalScores[data.id] = 0;
      }
      broadcastState();
      toast(data.name + ' a rejoint');
      break;

    case 'action':
      handlePlayerAction(data.playerId, data.action);
      break;

    case 'ping':
      sendMsg({ type: 'pong' }, peerId);
      break;
  }
}

function handleDisconnect(playerId, peerId) {
  if (!gameState) return;
  delete peerToPlayer[peerId];
  if (gameState.phase === 'lobby') {
    gameState.players = gameState.players.filter(p => p.id !== playerId);
    delete gameState.totalScores[playerId];
    broadcastState();
    toast('Un joueur a quitt√©');
  }
}

// --- CLIENT MESSAGE HANDLING ---
function handleClientMessage(data) {
  switch(data.type) {
    case 'state':
      gameState = data.state;
      renderFromState();
      break;
    case 'error':
      toast(data.msg);
      break;
    case 'toast':
      toast(data.msg);
      break;
    case 'boom':
      triggerBoom();
      break;
    case 'pong':
      break;
  }
}

// --- BROADCAST (h√¥te ‚Üí tous les clients) ---
function broadcastState() {
  if (sendMsg) sendMsg({ type: 'state', state: gameState });
  renderFromState();
}
function broadcastToast(msg) {
  if (sendMsg) sendMsg({ type: 'toast', msg });
  toast(msg);
}
function broadcastBoom() {
  if (sendMsg) sendMsg({ type: 'boom' });
  triggerBoom();
}
function sendToHost(data) {
  // Client ‚Üí h√¥te : envoyer √† tous (l'h√¥te recevra)
  // Trystero envoie √† tous les peers dans la room
  if (sendMsg) sendMsg(data);
}

// --- LOBBY ---
function showLobby() {
  showScreen('screen-lobby');
  document.getElementById('lobby-code').textContent = roomCode;
  generateQR();
  renderLobby();
}
function generateQR() {
  const url = window.location.href.split('?')[0] + '?room=' + roomCode;
  const container = document.getElementById('qr-container');
  container.innerHTML = '';
  try {
    new QRCode(container, { text: url, width: 180, height: 180, colorDark: '#1a1a2e', colorLight: '#ffffff', correctLevel: QRCode.CorrectLevel.M });
  } catch(e) {
    container.innerHTML = '<p style="color:#333;font-size:.75em;padding:8px;word-break:break-all">' + url + '</p>';
  }
}
function renderLobby() {
  if (!gameState) return;
  const list = document.getElementById('lobby-players');
  list.innerHTML = gameState.players.map(p =>
    `<li>${p.name} ${p.isHost ? '<span class="host-badge">H√îTE</span>' : ''}${p.id === myPlayerId ? ' (vous)' : ''}</li>`
  ).join('');
  const startBtn = document.getElementById('start-btn');
  startBtn.style.display = (isHost && gameState.players.length >= 2) ? '' : 'none';
}
function copyCode() {
  const url = window.location.href.split('?')[0] + '?room=' + roomCode;
  navigator.clipboard.writeText(url).then(() => toast('Lien copi√© !')).catch(() => toast(roomCode));
}
function leaveLobby() {
  if (trysteroRoom) { try { trysteroRoom.leave(); } catch(e) {} trysteroRoom = null; }
  gameState = null;
  isHost = false;
  connectedPeers = new Set();
  peerToPlayer = {};
  sendMsg = null;
  getMsg = null;
  showScreen('screen-menu');
}
function backToMenu() {
  if (trysteroRoom) { try { trysteroRoom.leave(); } catch(e) {} trysteroRoom = null; }
  gameState = null;
  isHost = false;
  connectedPeers = new Set();
  peerToPlayer = {};
  sendMsg = null;
  getMsg = null;
  showScreen('screen-menu');
}

// --- DECK CREATION ---
function createDeck() {
  const deck = [];
  for (const [val, count] of Object.entries(CARD_COUNTS)) {
    for (let i = 0; i < count; i++) deck.push(parseInt(val));
  }
  return shuffle(deck);
}
function shuffle(arr) {
  const a = [...arr];
  for (let i = a.length - 1; i > 0; i--) {
    const j = Math.floor(Math.random() * (i + 1));
    [a[i], a[j]] = [a[j], a[i]];
  }
  return a;
}

// --- START GAME (HOST ONLY) ---
function startGame() {
  if (!isHost || gameState.players.length < 2) return;
  initRound();
}
function initRound() {
  const deck = createDeck();
  const hands = {}, revealed = {};
  gameState.players.forEach(p => {
    const cards = [];
    for (let r = 0; r < ROWS; r++) {
      const row = [];
      for (let c = 0; c < COLS; c++) row.push(deck.pop());
      cards.push(row);
    }
    hands[p.id] = cards;
    revealed[p.id] = Array.from({length: ROWS}, () => [false,false,false,false]);
  });
  const discardTop = deck.pop();
  gameState.round++;
  gameState.phase = 'reveal_initial';
  gameState.deck = deck;
  gameState.discard = [discardTop];
  gameState.hands = hands;
  gameState.revealed = revealed;
  gameState.eliminated = {};
  gameState.players.forEach(p => { gameState.eliminated[p.id] = [false,false,false,false]; });
  gameState.currentPlayerIndex = -1;
  gameState.initialReveals = {};
  gameState.players.forEach(p => gameState.initialReveals[p.id] = 0);
  gameState.turnPhase = null;
  gameState.drawnCard = null;
  gameState.drawnFrom = null;
  gameState.drawnByPlayerId = null;
  gameState.lastRoundTriggeredBy = null;
  gameState.lastRoundTurnsLeft = -1;
  gameState.roundScores = {};
  broadcastToast('Manche ' + gameState.round + ' - Retournez 2 cartes !');
  broadcastState();
}

// --- PLAYER ACTIONS ---
function performAction(action) {
  if (isHost) {
    handlePlayerAction(myPlayerId, action);
  } else {
    sendToHost({ type: 'action', playerId: myPlayerId, action });
  }
}
function handlePlayerAction(playerId, action) {
  if (!isHost || !gameState) return;
  switch(gameState.phase) {
    case 'reveal_initial': handleRevealInitial(playerId, action); break;
    case 'playing': handlePlayingAction(playerId, action); break;
  }
}
function handleRevealInitial(playerId, action) {
  if (action.type !== 'reveal') return;
  const { row, col } = action;
  if (gameState.revealed[playerId][row][col]) return;
  if (gameState.eliminated[playerId][col]) return;
  if (gameState.initialReveals[playerId] >= 2) return;
  gameState.revealed[playerId][row][col] = true;
  gameState.initialReveals[playerId]++;
  const allDone = gameState.players.every(p => gameState.initialReveals[p.id] >= 2);
  if (allDone) {
    let maxSum = -Infinity, startIdx = 0;
    gameState.players.forEach((p, idx) => {
      let sum = 0;
      for (let r = 0; r < ROWS; r++) for (let c = 0; c < COLS; c++) {
        if (gameState.revealed[p.id][r][c]) sum += gameState.hands[p.id][r][c];
      }
      if (sum > maxSum) { maxSum = sum; startIdx = idx; }
    });
    gameState.currentPlayerIndex = startIdx;
    gameState.phase = 'playing';
    gameState.turnPhase = 'draw';
    broadcastToast(gameState.players[startIdx].name + ' commence !');
  }
  broadcastState();
}
function handlePlayingAction(playerId, action) {
  const currentPlayer = gameState.players[gameState.currentPlayerIndex];
  if (playerId !== currentPlayer.id) return;
  switch(action.type) {
    case 'draw_deck':
      if (gameState.turnPhase !== 'draw') return;
      if (gameState.deck.length === 0) reshuffleDeck();
      gameState.drawnCard = gameState.deck.pop();
      gameState.drawnFrom = 'deck';
      gameState.drawnByPlayerId = playerId;
      gameState.turnPhase = 'drawn_from_pile';
      broadcastState();
      break;
    case 'draw_discard':
      if (gameState.turnPhase !== 'draw') return;
      if (gameState.discard.length === 0) return;
      gameState.drawnCard = gameState.discard.pop();
      gameState.drawnFrom = 'discard';
      gameState.drawnByPlayerId = playerId;
      gameState.turnPhase = 'place_mandatory';
      broadcastState();
      break;
    case 'place_card': {
      if (gameState.turnPhase !== 'drawn_from_pile' && gameState.turnPhase !== 'place_mandatory') return;
      const { row, col } = action;
      if (gameState.eliminated[playerId][col]) return;
      const oldCard = gameState.hands[playerId][row][col];
      gameState.hands[playerId][row][col] = gameState.drawnCard;
      gameState.revealed[playerId][row][col] = true;
      gameState.discard.push(oldCard);
      gameState.drawnCard = null;
      gameState.drawnByPlayerId = null;
      checkColumnElimination(playerId);
      endTurn();
      break;
    }
    case 'discard_drawn':
      if (gameState.turnPhase !== 'drawn_from_pile') return;
      gameState.discard.push(gameState.drawnCard);
      gameState.drawnCard = null;
      gameState.drawnByPlayerId = null;
      gameState.turnPhase = 'must_reveal';
      broadcastState();
      break;
    case 'reveal_card': {
      if (gameState.turnPhase !== 'must_reveal') return;
      const rr = action.row, rc = action.col;
      if (gameState.revealed[playerId][rr][rc]) return;
      if (gameState.eliminated[playerId][rc]) return;
      gameState.revealed[playerId][rr][rc] = true;
      checkColumnElimination(playerId);
      endTurn();
      break;
    }
  }
}
function checkColumnElimination(playerId) {
  for (let c = 0; c < COLS; c++) {
    if (gameState.eliminated[playerId][c]) continue;
    let allRevealed = true, allSame = true, val = null;
    for (let r = 0; r < ROWS; r++) {
      if (!gameState.revealed[playerId][r][c]) { allRevealed = false; break; }
      if (val === null) val = gameState.hands[playerId][r][c];
      else if (gameState.hands[playerId][r][c] !== val) allSame = false;
    }
    if (allRevealed && allSame) {
      gameState.eliminated[playerId][c] = true;
      for (let r = 0; r < ROWS; r++) gameState.discard.push(gameState.hands[playerId][r][c]);
      broadcastToast(getPlayerName(playerId) + ' √©limine une colonne de ' + val + ' !');
      broadcastBoom();
    }
  }
}
function reshuffleDeck() {
  if (gameState.discard.length <= 1) return;
  const top = gameState.discard.pop();
  gameState.deck = shuffle(gameState.discard);
  gameState.discard = [top];
}
function endTurn() {
  const playerId = gameState.players[gameState.currentPlayerIndex].id;
  if (gameState.lastRoundTriggeredBy === null && isAllRevealed(playerId)) {
    gameState.lastRoundTriggeredBy = playerId;
    gameState.lastRoundTurnsLeft = gameState.players.length - 1;
    broadcastToast(getPlayerName(playerId) + ' a tout r√©v√©l√© ! Dernier tour !');
  }
  if (gameState.lastRoundTriggeredBy !== null) {
    gameState.lastRoundTurnsLeft--;
    if (gameState.lastRoundTurnsLeft <= 0) { endRound(); return; }
  }
  advancePlayer();
  gameState.turnPhase = 'draw';
  gameState.drawnCard = null;
  gameState.drawnFrom = null;
  gameState.drawnByPlayerId = null;
  broadcastState();
}
function advancePlayer() {
  gameState.currentPlayerIndex = (gameState.currentPlayerIndex + 1) % gameState.players.length;
}
function isAllRevealed(playerId) {
  for (let r = 0; r < ROWS; r++) for (let c = 0; c < COLS; c++) {
    if (gameState.eliminated[playerId][c]) continue;
    if (!gameState.revealed[playerId][r][c]) return false;
  }
  return true;
}
function getPlayerName(id) {
  const p = gameState.players.find(pl => pl.id === id);
  return p ? p.name : '?';
}

// --- END ROUND ---
function endRound() {
  gameState.players.forEach(p => {
    for (let r = 0; r < ROWS; r++) for (let c = 0; c < COLS; c++) gameState.revealed[p.id][r][c] = true;
  });
  const scores = {};
  gameState.players.forEach(p => {
    let sum = 0;
    for (let r = 0; r < ROWS; r++) for (let c = 0; c < COLS; c++) {
      if (!gameState.eliminated[p.id][c]) sum += gameState.hands[p.id][r][c];
    }
    scores[p.id] = sum;
  });
  const trigId = gameState.lastRoundTriggeredBy;
  if (trigId) {
    const trigScore = scores[trigId];
    const minOther = Math.min(...gameState.players.filter(p => p.id !== trigId).map(p => scores[p.id]));
    if (trigScore >= minOther) {
      scores[trigId] *= 2;
      broadcastToast(getPlayerName(trigId) + ' n\'a pas le score le plus bas ! Score doubl√© !');
    }
  }
  gameState.roundScores = scores;
  gameState.players.forEach(p => { gameState.totalScores[p.id] = (gameState.totalScores[p.id] || 0) + scores[p.id]; });
  const gameOver = gameState.players.some(p => gameState.totalScores[p.id] >= END_SCORE);
  gameState.phase = gameOver ? 'game_over_reveal' : 'round_reveal';
  gameState.drawnCard = null;
  gameState.drawnByPlayerId = null;
  broadcastState();
}
function nextRound() {
  if (!isHost) return;
  initRound();
}

// --- RENDER ---
function renderFromState() {
  if (!gameState) return;
  switch(gameState.phase) {
    case 'lobby':
      showScreen('screen-lobby');
      document.getElementById('lobby-code').textContent = roomCode;
      renderLobby();
      break;
    case 'reveal_initial':
    case 'playing':
      showScreen('screen-game');
      renderGame();
      break;
    case 'round_reveal':
      showScreen('screen-round-reveal');
      renderRoundReveal(false);
      break;
    case 'game_over_reveal':
      showScreen('screen-round-reveal');
      renderRoundReveal(true);
      break;
    case 'round_end':
      showScreen('screen-round-scores');
      renderRoundScores();
      break;
    case 'game_over':
      showScreen('screen-final-scores');
      renderFinalScores();
      break;
  }
}

function renderRoundReveal(isGameOver) {
  document.getElementById('reveal-subtitle').textContent = isGameOver ? 'Partie termin√©e ! Voici les grilles finales :' : 'Manche ' + gameState.round + ' termin√©e !';
  const summary = document.getElementById('reveal-summary');
  const sorted = [...gameState.players].sort((a,b) => (gameState.roundScores[a.id]||0) - (gameState.roundScores[b.id]||0));
  const bestScore = gameState.roundScores[sorted[0].id] || 0;
  let html = '';
  sorted.forEach(p => {
    const rs = gameState.roundScores[p.id] || 0;
    const isBest = rs === bestScore;
    const isTriggerer = p.id === gameState.lastRoundTriggeredBy;
    html += `<div class="player-result ${isBest?'best':''}"><div><strong>${p.name}</strong>${isTriggerer?' üîî':''}${p.id===myPlayerId?' (vous)':''}<div style="display:flex;gap:2px;margin-top:4px">`;
    for (let r = 0; r < ROWS; r++) for (let c = 0; c < COLS; c++) {
      if (gameState.eliminated[p.id][c]) html += '<div style="width:20px;height:28px;opacity:0"></div>';
      else { const val = gameState.hands[p.id][r][c]; html += `<div class="card ${getCardClass(val)}" style="width:20px;height:28px;font-size:.55em;border:1px solid rgba(255,255,255,.1);border-radius:3px;cursor:default">${val}</div>`; }
    }
    html += `</div></div><span class="score-val">${rs>0?'+':''}${rs} pts</span></div>`;
  });
  summary.innerHTML = html;
}

function showRoundScoreTable() {
  if (!gameState) return;
  if (gameState.phase === 'game_over_reveal') {
    const sorted = [...gameState.players].sort((a,b) => (gameState.totalScores[a.id]||0) - (gameState.totalScores[b.id]||0));
    gameState.players.forEach(p => updateLeaderboard(p.name, p.id === sorted[0].id));
    gameState.phase = 'game_over';
    if (isHost) broadcastState(); else renderFromState();
  } else {
    gameState.phase = 'round_end';
    if (isHost) broadcastState(); else renderFromState();
  }
}

function renderGame() {
  const pilesArea = document.getElementById('piles-area');
  const playersArea = document.getElementById('players-area');
  const actionBar = document.getElementById('action-bar');
  const statusEl = document.getElementById('game-status');
  const roundEl = document.getElementById('round-info');
  roundEl.textContent = 'Manche ' + gameState.round;
  const isMyTurn = gameState.phase === 'playing' && gameState.players[gameState.currentPlayerIndex]?.id === myPlayerId;

  if (gameState.phase === 'reveal_initial') {
    const myReveals = gameState.initialReveals[myPlayerId] || 0;
    statusEl.textContent = myReveals < 2 ? 'Retournez ' + (2-myReveals) + ' carte(s)' : 'En attente des autres joueurs...';
  } else if (gameState.phase === 'playing') {
    const cp = gameState.players[gameState.currentPlayerIndex];
    if (isMyTurn) {
      switch(gameState.turnPhase) {
        case 'draw': statusEl.textContent = 'Piochez une carte'; break;
        case 'drawn_from_pile': statusEl.textContent = 'üìå Placez le ' + gameState.drawnCard + ' OU d√©faussez-le'; break;
        case 'place_mandatory': statusEl.textContent = 'üìå Vous DEVEZ placer le ' + gameState.drawnCard; break;
        case 'must_reveal': statusEl.textContent = 'üëÜ Retournez une carte face cach√©e'; break;
        default: statusEl.textContent = '√Ä vous de jouer';
      }
    } else {
      statusEl.textContent = 'Tour de ' + cp.name;
      if (gameState.drawnCard !== null && gameState.drawnByPlayerId) {
        if (gameState.turnPhase === 'drawn_from_pile') statusEl.textContent += ' ‚Äî a pioch√© un ' + gameState.drawnCard;
        else if (gameState.turnPhase === 'place_mandatory') statusEl.textContent += ' ‚Äî doit placer le ' + gameState.drawnCard;
        else if (gameState.turnPhase === 'must_reveal') statusEl.textContent += ' ‚Äî doit retourner une carte';
      }
    }
    if (gameState.lastRoundTriggeredBy) statusEl.textContent += ' üîî Dernier tour !';
  }

  const discardTop = gameState.discard.length > 0 ? gameState.discard[gameState.discard.length-1] : null;
  const deckCount = gameState.deck ? gameState.deck.length : 0;
  let pilesHtml = `<div class="pile"><div class="pile-label">Pioche (${deckCount})</div><div class="card face-down" id="pile-deck" onclick="clickDeck()"></div></div>`;
  pilesHtml += '<div class="pile"><div class="pile-label">D√©fausse</div>';
  if (discardTop !== null) pilesHtml += `<div class="card ${getCardClass(discardTop)}" id="pile-discard" onclick="clickDiscard()">${discardTop}</div>`;
  else pilesHtml += '<div class="card face-down" style="opacity:.3"></div>';
  pilesHtml += '</div>';
  if (gameState.drawnCard !== null && gameState.drawnByPlayerId) {
    const isDrawnByMe = gameState.drawnByPlayerId === myPlayerId;
    pilesHtml += `<div class="pile"><div class="pile-label">${isDrawnByMe ? 'En main' : getPlayerName(gameState.drawnByPlayerId)}</div>`;
    if (isMyTurn && gameState.turnPhase === 'drawn_from_pile') pilesHtml += `<div class="card ${getCardClass(gameState.drawnCard)} highlight" onclick="discardDrawn()" title="Cliquer pour d√©fausser">${gameState.drawnCard}</div><div style="font-size:.65em;color:#e74c3c;margin-top:2px">Tap = d√©fausser</div>`;
    else if (isMyTurn && gameState.turnPhase === 'place_mandatory') pilesHtml += `<div class="card ${getCardClass(gameState.drawnCard)} highlight">${gameState.drawnCard}</div><div style="font-size:.65em;color:#f1c40f;margin-top:2px">Placez sur votre grille</div>`;
    else pilesHtml += `<div class="card ${getCardClass(gameState.drawnCard)} highlight">${gameState.drawnCard}</div>`;
    pilesHtml += '</div>';
  }
  pilesArea.innerHTML = pilesHtml;

  const orderedPlayers = [...gameState.players].sort((a,b) => a.id===myPlayerId?-1:b.id===myPlayerId?1:0);
  let playersHtml = '';
  orderedPlayers.forEach(p => {
    const isMe = p.id === myPlayerId;
    const isCurrent = gameState.phase === 'playing' && gameState.players[gameState.currentPlayerIndex]?.id === p.id;
    const visibleScore = calcVisibleScore(p.id);
    const totalScore = gameState.totalScores[p.id] || 0;
    playersHtml += `<div class="player-zone ${isCurrent?'current-turn':''} ${isMe?'is-me':''}">`;
    playersHtml += `<div class="player-header"><span class="player-name">${p.name}${isMe?' (vous)':''}</span><span>${isCurrent?'<span class="turn-indicator">‚ñ∂ </span>':''}<span class="player-score">Visible: ${visibleScore} | Total: ${totalScore}</span></span></div>`;
    playersHtml += '<div class="card-container">';
    for (let r = 0; r < ROWS; r++) {
      playersHtml += '<div class="card-row">';
      for (let c = 0; c < COLS; c++) {
        if (gameState.eliminated[p.id][c]) playersHtml += '<div class="card eliminated"></div>';
        else if (gameState.revealed[p.id][r][c]) { const val = gameState.hands[p.id][r][c]; playersHtml += `<div class="card ${getCardClass(val)}">${val}</div>`; }
        else { const sel = isCardSelectable(p.id,r,c); playersHtml += `<div class="card face-down ${sel?'selectable':''}" onclick="clickCard('${p.id}',${r},${c})"></div>`; }
      }
      playersHtml += '</div>';
    }
    playersHtml += '</div></div>';
  });
  playersArea.innerHTML = playersHtml;

  if (isMyTurn && (gameState.turnPhase === 'drawn_from_pile' || gameState.turnPhase === 'place_mandatory')) {
    playersArea.querySelectorAll('.player-zone.is-me .card:not(.eliminated)').forEach(cardEl => {
      if (!cardEl.classList.contains('face-down')) {
        const row = cardEl.closest('.card-row');
        const container = cardEl.closest('.card-container');
        if (row && container) {
          const rows = Array.from(container.children);
          const r = rows.indexOf(row);
          const cols = Array.from(row.children);
          const c = cols.indexOf(cardEl);
          if (r >= 0 && c >= 0 && !gameState.eliminated[myPlayerId][c]) {
            cardEl.style.cursor = 'pointer';
            cardEl.classList.add('selectable');
            cardEl.onclick = () => clickCard(myPlayerId, r, c);
          }
        }
      }
    });
  }

  if (isMyTurn && gameState.turnPhase === 'drawn_from_pile') {
    actionBar.style.display = '';
    actionBar.innerHTML = `<button class="danger" onclick="discardDrawn()" style="font-size:1em;padding:14px 28px">üóëÔ∏è D√©fausser le ${gameState.drawnCard} et retourner une carte</button>`;
  } else if (isMyTurn && gameState.turnPhase === 'must_reveal') {
    actionBar.style.display = '';
    actionBar.innerHTML = '<div style="color:#f1c40f;font-weight:600;padding:8px">üëÜ Cliquez sur une carte face cach√©e pour la retourner</div>';
  } else {
    actionBar.style.display = 'none';
    actionBar.innerHTML = '';
  }
}

function isCardSelectable(playerId, row, col) {
  if (gameState.eliminated[playerId][col]) return false;
  const isMe = playerId === myPlayerId;
  if (gameState.phase === 'reveal_initial') return isMe && !gameState.revealed[playerId][row][col] && (gameState.initialReveals[playerId]||0) < 2;
  if (gameState.phase === 'playing') {
    const isMyTurn = gameState.players[gameState.currentPlayerIndex]?.id === myPlayerId;
    if (!isMe || !isMyTurn) return false;
    if (gameState.turnPhase === 'must_reveal') return !gameState.revealed[playerId][row][col];
    if (gameState.turnPhase === 'drawn_from_pile' || gameState.turnPhase === 'place_mandatory') return true;
  }
  return false;
}
function getCardClass(val) {
  if (val <= -2) return 'val-neg2';
  if (val === -1) return 'val-neg1';
  if (val === 0) return 'val-0';
  return 'val-' + val;
}
function calcVisibleScore(playerId) {
  let sum = 0;
  for (let r = 0; r < ROWS; r++) for (let c = 0; c < COLS; c++) {
    if (gameState.eliminated[playerId][c]) continue;
    if (gameState.revealed[playerId][r][c]) sum += gameState.hands[playerId][r][c];
  }
  return sum;
}

// --- CLICK HANDLERS ---
function clickDeck() {
  const isMyTurn = gameState.phase === 'playing' && gameState.players[gameState.currentPlayerIndex]?.id === myPlayerId;
  if (!isMyTurn || gameState.turnPhase !== 'draw') return;
  performAction({ type: 'draw_deck' });
}
function clickDiscard() {
  const isMyTurn = gameState.phase === 'playing' && gameState.players[gameState.currentPlayerIndex]?.id === myPlayerId;
  if (!isMyTurn || gameState.turnPhase !== 'draw') return;
  performAction({ type: 'draw_discard' });
}
function clickCard(playerId, row, col) {
  if (gameState.phase === 'reveal_initial') {
    if (playerId !== myPlayerId) return;
    performAction({ type: 'reveal', row, col });
    return;
  }
  if (gameState.phase === 'playing') {
    const isMyTurn = gameState.players[gameState.currentPlayerIndex]?.id === myPlayerId;
    if (!isMyTurn || playerId !== myPlayerId) return;
    if (gameState.turnPhase === 'must_reveal') { if (!gameState.revealed[playerId][row][col]) performAction({ type: 'reveal_card', row, col }); return; }
    if (gameState.turnPhase === 'drawn_from_pile' || gameState.turnPhase === 'place_mandatory') { if (!gameState.eliminated[playerId][col]) performAction({ type: 'place_card', row, col }); return; }
  }
}
function discardDrawn() { performAction({ type: 'discard_drawn' }); }

// --- SCORES ---
function renderRoundScores() {
  const table = document.getElementById('round-scores-table');
  let html = '<thead><tr><th>Joueur</th><th>Manche</th><th>Total</th></tr></thead><tbody>';
  const sorted = [...gameState.players].sort((a,b) => (gameState.totalScores[a.id]||0) - (gameState.totalScores[b.id]||0));
  sorted.forEach((p,i) => {
    const rs = gameState.roundScores[p.id]||0, ts = gameState.totalScores[p.id]||0;
    const isTriggerer = p.id === gameState.lastRoundTriggeredBy;
    html += `<tr${i===0?' class="winner"':''}><td>${i===0?'<span class="winner-name">':''}${p.name}${isTriggerer?' üîî':''}${p.id===myPlayerId?' (vous)':''}${i===0?'</span>':''}</td><td>${rs>0?'+':''}${rs}</td><td class="total">${ts}</td></tr>`;
  });
  html += '</tbody>';
  table.innerHTML = html;
  document.getElementById('next-round-btn').style.display = isHost ? '' : 'none';
}
function renderFinalScores() {
  const table = document.getElementById('final-scores-table');
  let html = '<thead><tr><th>üèÜ</th><th>Joueur</th><th>Score</th></tr></thead><tbody>';
  const sorted = [...gameState.players].sort((a,b) => (gameState.totalScores[a.id]||0) - (gameState.totalScores[b.id]||0));
  const winner = sorted[0];
  document.getElementById('final-winner-banner').innerHTML = `<div class="winner-name" style="font-size:1.8em">üéâ ${winner.name} remporte la partie ! üéâ</div>`;
  sorted.forEach((p,i) => {
    const ts = gameState.totalScores[p.id]||0;
    const medal = i===0?'ü•á':i===1?'ü•à':i===2?'ü•â':(i+1);
    html += `<tr${i===0?' class="winner"':''}><td>${medal}</td><td>${i===0?'<span class="winner-name">':''}${p.name}${p.id===myPlayerId?' (vous)':''}${i===0?'</span>':''}</td><td class="total">${ts}</td></tr>`;
  });
  html += '</tbody>';
  table.innerHTML = html;
  renderLeaderboard('final-leaderboard');
}

// --- RULES MODAL ---
function showRules() {
  showModal('R√®gles Skyjo', `
    <div style="text-align:left;font-size:.85em;max-height:60vh;overflow-y:auto;line-height:1.6">
    <b>But :</b> Avoir le score le plus bas √† la fin de la partie.<br><br>
    <b>D√©but :</b> Chaque joueur retourne 2 cartes. Le joueur avec la plus haute somme commence.<br><br>
    <b>Tour :</b><br>
    ‚Ä¢ Piochez depuis la <b>pioche</b> ou la <b>d√©fausse</b><br>
    ‚Ä¢ Si pioche : placez la carte sur votre grille OU d√©faussez-la et retournez une carte face cach√©e<br>
    ‚Ä¢ Si d√©fausse : vous DEVEZ placer la carte sur votre grille<br><br>
    <b>Colonnes :</b> 3 cartes identiques dans une colonne ‚Üí √©limin√©es !<br><br>
    <b>Fin de manche :</b> Quand un joueur a toutes ses cartes visibles, chaque autre joueur joue un dernier tour.<br><br>
    <b>Score doubl√© :</b> Si le joueur qui termine n'a pas le score le plus bas, son score est doubl√© !<br><br>
    <b>Fin de partie :</b> Quand un joueur atteint 100 points. Le joueur avec le score le plus bas gagne !
    </div>
  `, [{ text: 'Compris !', action: 'closeModal()' }]);
}
function showModal(title, text, buttons) {
  document.getElementById('modal-title').textContent = title;
  document.getElementById('modal-text').innerHTML = text;
  const btnContainer = document.getElementById('modal-buttons');
  btnContainer.innerHTML = buttons.map(b => `<button onclick="${b.action}">${b.text}</button>`).join('');
  document.getElementById('modal').classList.add('active');
}
function closeModal() { document.getElementById('modal').classList.remove('active'); }

// --- TOAST ---
function toast(msg) {
  const el = document.getElementById('toast');
  el.textContent = msg;
  el.classList.add('show');
  setTimeout(() => el.classList.remove('show'), 2500);
}

// --- EXPOSE FUNCTIONS TO HTML onclick ---
// N√©cessaire car on est en type="module"
Object.assign(window, {
  createGame, joinGame, showJoinScreen, showScreen,
  leaveLobby, backToMenu, startGame, nextRound,
  clickDeck, clickDiscard, clickCard, discardDrawn,
  toggleFullscreen, closeFsTip,
  showRules, showModal, closeModal,
  copyCode, showRoundScoreTable,
});

// --- URL PARAMS (auto-join) ---
window.addEventListener('load', () => {
  const params = new URLSearchParams(window.location.search);
  const room = params.get('room');
  if (room) {
    document.getElementById('room-input').value = room;
    showJoinScreen();
  }
  renderLeaderboard('menu-leaderboard');
});
</script>
</body>
</html>
