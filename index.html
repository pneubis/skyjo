<!DOCTYPE html>
<html lang="fr">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no, maximum-scale=1.0">
<title>Skyjo Multijoueur</title>
<link rel="icon" href="https://public-frontend-cos.metadl.com/mgx/img/favicon_atoms.ico" type="image/x-icon">
<script src="https://unpkg.com/peerjs@1.5.4/dist/peerjs.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/davidshimjs-qrcodejs@0.0.2/qrcode.min.js"></script>

<!-- ============================================================
  STYLES
============================================================ -->
<style>
/* --- Reset & Base --- */
*{margin:0;padding:0;box-sizing:border-box;-webkit-tap-highlight-color:transparent}
body{font-family:'Segoe UI',system-ui,-apple-system,sans-serif;background:#1a1a2e;color:#fff;min-height:100vh;overflow-x:hidden;user-select:none}

/* --- Screens --- */
.screen{display:none;flex-direction:column;align-items:center;justify-content:center;min-height:100vh;padding:16px}
.screen.active{display:flex}

/* --- Typography --- */
h1{font-size:2.2em;font-weight:700;margin-bottom:8px;background:linear-gradient(135deg,#9b59b6,#3498db);-webkit-background-clip:text;-webkit-text-fill-color:transparent;background-clip:text}
h2{font-size:1.4em;font-weight:600;margin-bottom:16px;color:#ccc}
.subtitle{color:#888;font-size:0.9em;margin-bottom:24px}

/* --- Buttons --- */
button{background:linear-gradient(135deg,#9b59b6,#8e44ad);color:#fff;border:none;padding:14px 32px;border-radius:12px;font-size:1em;font-weight:600;cursor:pointer;transition:all .2s;touch-action:manipulation;min-height:48px}
button:hover{transform:translateY(-2px);box-shadow:0 4px 15px rgba(155,89,182,.4)}
button:active{transform:translateY(0)}
button.secondary{background:rgba(255,255,255,.1);backdrop-filter:blur(10px)}
button.secondary:hover{background:rgba(255,255,255,.2);box-shadow:none}
button.danger{background:linear-gradient(135deg,#e74c3c,#c0392b)}

/* --- Inputs --- */
input{background:rgba(255,255,255,.1);border:2px solid rgba(255,255,255,.15);color:#fff;padding:14px 18px;border-radius:12px;font-size:1em;width:100%;max-width:320px;outline:none;transition:border-color .2s}
input:focus{border-color:#9b59b6}
input::placeholder{color:#666}

/* --- Layout Helpers --- */
.btn-group{display:flex;gap:12px;flex-wrap:wrap;justify-content:center;margin-top:16px}
.card-container{display:flex;flex-direction:column;gap:4px;margin:8px}
.card-row{display:flex;gap:4px;justify-content:center}

/* --- Cards --- */
.card{width:52px;height:72px;border-radius:8px;display:flex;align-items:center;justify-content:center;font-size:1.2em;font-weight:700;cursor:pointer;transition:all .2s;position:relative;border:2px solid rgba(255,255,255,.1)}
.card:active{transform:scale(.95)}
.card.face-down{background:linear-gradient(135deg,#4a4a6a,#3a3a5a);color:transparent;cursor:pointer}
.card.face-down::after{content:'?';color:#666;font-size:1.4em;position:absolute}
.card.eliminated{opacity:0;pointer-events:none;transform:scale(0)}
.card.selectable{animation:pulse 1s infinite;box-shadow:0 0 12px rgba(155,89,182,.6)}
.card.highlight{box-shadow:0 0 15px rgba(255,255,255,.5)}
@keyframes pulse{0%,100%{box-shadow:0 0 8px rgba(155,89,182,.4)}50%{box-shadow:0 0 18px rgba(155,89,182,.8)}}

/* Card color classes */
.card.val-neg2{background:linear-gradient(135deg,#27ae60,#2ecc71);color:#fff}
.card.val-neg1{background:linear-gradient(135deg,#2ecc71,#58d68d);color:#fff}
.card.val-0{background:linear-gradient(135deg,#2980b9,#3498db);color:#fff}
.card.val-1,.card.val-2,.card.val-3,.card.val-4{background:linear-gradient(135deg,#f39c12,#f1c40f);color:#333}
.card.val-5,.card.val-6,.card.val-7,.card.val-8{background:linear-gradient(135deg,#d35400,#e67e22);color:#fff}
.card.val-9,.card.val-10,.card.val-11,.card.val-12{background:linear-gradient(135deg,#c0392b,#e74c3c);color:#fff}

/* --- Piles --- */
.piles{display:flex;gap:20px;align-items:center;justify-content:center;margin:12px 0}
.pile{display:flex;flex-direction:column;align-items:center;gap:6px}
.pile-label{font-size:.75em;color:#888;text-transform:uppercase;letter-spacing:1px}
.pile .card{width:58px;height:80px;font-size:1.4em}

/* --- Player Areas --- */
.players-area{width:100%;max-width:700px;display:flex;flex-direction:column;gap:12px;padding:8px}
.player-zone{background:rgba(255,255,255,.05);border-radius:12px;padding:10px;border:2px solid transparent;transition:border-color .3s}
.player-zone.current-turn{border-color:#9b59b6}
.player-zone.is-me{border-color:rgba(52,152,219,.5)}
.player-zone.is-me.current-turn{
  border-color:#9b59b6;
  box-shadow:0 0 20px rgba(155,89,182,.3);
  background:rgba(155,89,182,.18);
  animation:myTurnPulse 2s ease-in-out infinite;
}
@keyframes myTurnPulse{
  0%,100%{background:rgba(155,89,182,.12);box-shadow:0 0 20px rgba(155,89,182,.3)}
  50%{background:rgba(155,89,182,.28);box-shadow:0 0 35px rgba(155,89,182,.6)}
}
.player-header{display:flex;justify-content:space-between;align-items:center;margin-bottom:6px;padding:0 4px}
.player-score{font-size:.85em;color:#888}
.player-badge{font-size:.7em;padding:2px 8px;border-radius:20px;background:rgba(155,89,182,.3);color:#bb86fc}
.turn-indicator{font-size:.7em;color:#f1c40f;font-weight:600}

/* --- Lobby --- */
.lobby-box{background:rgba(255,255,255,.05);border-radius:16px;padding:24px;max-width:400px;width:100%;text-align:center}
.lobby-players{list-style:none;margin:16px 0;text-align:left}
.lobby-players li{padding:10px 16px;background:rgba(255,255,255,.05);border-radius:8px;margin-bottom:6px;display:flex;justify-content:space-between;align-items:center}
.lobby-players li .host-badge{font-size:.7em;background:#9b59b6;padding:2px 8px;border-radius:10px}
#qr-container{margin:16px auto;border-radius:12px;background:#fff;padding:8px;display:inline-block}
#qr-container img{display:block;border-radius:4px}
.room-code{font-family:monospace;font-size:1.8em;letter-spacing:4px;color:#bb86fc;margin:8px 0}
.copy-btn{font-size:.8em;padding:8px 16px;margin-top:4px}

/* --- Game Header --- */
.game-header{width:100%;max-width:700px;display:flex;justify-content:space-between;align-items:center;padding:8px 12px;background:rgba(255,255,255,.05);border-radius:12px;margin-bottom:8px}
.game-status{font-size:.85em;color:#ccc;text-align:center;flex:1}
.round-info{font-size:.75em;color:#888}

/* --- Action Bar --- */
.action-bar{position:fixed;bottom:0;left:0;right:0;background:rgba(26,26,46,.95);backdrop-filter:blur(10px);padding:12px 16px;display:flex;justify-content:center;gap:10px;border-top:1px solid rgba(255,255,255,.1);z-index:100}
.action-bar button{padding:10px 20px;font-size:.85em}

/* --- Scores Screen --- */
.scores-table{width:100%;max-width:420px;border-collapse:collapse;margin:12px 0}
.scores-table th{color:#888;font-weight:600;font-size:.75em;text-transform:uppercase;letter-spacing:.8px;padding:8px 10px;border-bottom:1px solid rgba(255,255,255,.08)}
.scores-table td{padding:11px 10px;text-align:center;border-bottom:1px solid rgba(255,255,255,.06);font-size:.95em}
.scores-table td:first-child{text-align:left;padding-left:14px}
.scores-table tr.winner td{background:rgba(46,204,113,.1)}
.scores-table tr.winner td:first-child{border-left:3px solid #2ecc71}
.scores-table td.total{font-weight:700;color:#bb86fc;font-size:1.05em}
.scores-table td.round-score-pos{color:#e74c3c}
.scores-table td.round-score-neg{color:#2ecc71}

/* --- Score Cards (Final Screen) --- */
.score-cards{width:100%;max-width:420px;display:flex;flex-direction:column;gap:8px;margin:12px 0}
.score-card{display:flex;align-items:center;gap:12px;padding:12px 14px;border-radius:14px;background:rgba(255,255,255,.05);border:1px solid rgba(255,255,255,.07)}
.score-card.rank-1{background:rgba(241,196,15,.08);border-color:rgba(241,196,15,.25)}
.score-card.rank-2{background:rgba(192,192,192,.06);border-color:rgba(192,192,192,.18)}
.score-card.rank-3{background:rgba(205,127,50,.06);border-color:rgba(205,127,50,.18)}
.score-card-medal{font-size:1.6em;width:36px;text-align:center;flex-shrink:0}
.score-card-name{flex:1;font-weight:600;font-size:.95em;line-height:1.2}
.score-card-name small{display:block;color:#888;font-size:.75em;font-weight:400;margin-top:2px}
.score-card-pts{font-weight:800;font-size:1.2em;color:#bb86fc;text-align:right;flex-shrink:0}

/* --- Winner Banner --- */
.winner-banner{text-align:center;margin:8px 0 4px;padding:14px 16px;background:rgba(241,196,15,.08);border-radius:16px;border:1px solid rgba(241,196,15,.2)}
.winner-name{display:inline-block;animation:winnerZoom 1.5s ease-in-out infinite alternate;font-size:1.2em;font-weight:800;color:#f1c40f}
@keyframes winnerZoom{0%{transform:scale(1);text-shadow:0 0 5px rgba(241,196,15,.3)}100%{transform:scale(1.12);text-shadow:0 0 18px rgba(241,196,15,.6)}}

/* --- Round Reveal Screen --- */
.reveal-summary{width:100%;max-width:420px;display:flex;flex-direction:column;gap:7px}
.reveal-summary .player-result{background:rgba(255,255,255,.05);border-radius:12px;padding:10px 14px;display:flex;align-items:center;gap:10px;border:1px solid rgba(255,255,255,.07)}
.reveal-summary .player-result.best{border-color:#2ecc71;background:rgba(46,204,113,.08)}
.reveal-summary .player-result .pr-name{flex:1;font-weight:600;font-size:.9em}
.reveal-summary .player-result .pr-name small{display:block;color:#888;font-size:.75em;font-weight:400}
.reveal-summary .player-result .pr-grid{display:grid;grid-template-columns:repeat(4,1fr);gap:2px;flex-shrink:0}
.reveal-summary .player-result .pr-grid .mini-card{width:22px;height:30px;border-radius:3px;display:flex;align-items:center;justify-content:center;font-size:.52em;font-weight:700;border:1px solid rgba(255,255,255,.1);cursor:default}
.reveal-summary .player-result .pr-grid .mini-card.empty{opacity:0;pointer-events:none}
.reveal-summary .player-result .score-val{font-size:1.1em;font-weight:800;color:#bb86fc;min-width:52px;text-align:right;flex-shrink:0}

/* --- Duration Badge --- */
.duration-badge{display:inline-flex;align-items:center;gap:6px;margin:10px auto 4px;padding:7px 16px;background:rgba(255,255,255,.05);border-radius:20px;color:#888;font-size:.82em;border:1px solid rgba(255,255,255,.08)}
.duration-badge strong{color:#bb86fc;font-size:1em}

/* --- Leaderboard --- */
.leaderboard-box{background:rgba(255,255,255,.04);border-radius:14px;padding:14px 16px;max-width:420px;width:100%;margin-top:12px;border:1px solid rgba(255,255,255,.07)}
.leaderboard-box h3{font-size:.75em;color:#666;margin-bottom:10px;text-transform:uppercase;letter-spacing:1px;text-align:center}
.lb-row{display:flex;align-items:center;padding:7px 4px;border-bottom:1px solid rgba(255,255,255,.05);gap:8px}
.lb-row:last-child{border-bottom:none}
.lb-rank{width:26px;font-weight:700;color:#f1c40f;font-size:.95em;flex-shrink:0}
.lb-name{flex:1;font-weight:500;font-size:.9em;white-space:nowrap;overflow:hidden;text-overflow:ellipsis}
.lb-wins{color:#2ecc71;font-weight:700;font-size:.9em;flex-shrink:0}
.lb-games{color:#666;font-size:.78em;margin-left:4px;flex-shrink:0}

/* --- Scrollable Score Screens --- */
.score-screen-content{width:100%;max-width:420px;display:flex;flex-direction:column;align-items:center;overflow-y:auto;padding:0 4px 24px}

/* --- Toast --- */
.toast{position:fixed;top:20px;left:50%;transform:translateX(-50%);background:rgba(155,89,182,.9);color:#fff;padding:12px 24px;border-radius:12px;font-size:.9em;z-index:200;opacity:0;transition:opacity .3s;pointer-events:none}
.toast.show{opacity:1}

/* --- Modal --- */
.modal-overlay{position:fixed;inset:0;background:rgba(0,0,0,.7);display:none;align-items:center;justify-content:center;z-index:300;padding:16px}
.modal-overlay.active{display:flex}
.modal{background:#2a2a4a;border-radius:16px;padding:24px;max-width:400px;width:100%;text-align:center}
.modal h3{margin-bottom:12px;font-size:1.2em}
.modal p{color:#aaa;margin-bottom:16px;font-size:.9em}

/* --- Game Content Scroll --- */
.game-content{width:100%;overflow-y:auto;padding-bottom:80px;display:flex;flex-direction:column;align-items:center}

/* --- Boom Animation --- */
.boom-overlay{position:fixed;inset:0;pointer-events:none;z-index:150}
.boom-particle{position:absolute;border-radius:50%;pointer-events:none;animation:boomExplode .8s ease-out forwards}
@keyframes boomExplode{0%{opacity:1;transform:translate(0,0) scale(1)}100%{opacity:0;transform:translate(var(--dx),var(--dy)) scale(0)}}
.boom-text{position:fixed;top:50%;left:50%;transform:translate(-50%,-50%) scale(0);font-size:3em;font-weight:900;color:#f1c40f;text-shadow:0 0 30px rgba(241,196,15,.8),0 0 60px rgba(241,196,15,.4);z-index:160;pointer-events:none;animation:boomTextAnim .8s ease-out forwards}
@keyframes boomTextAnim{0%{transform:translate(-50%,-50%) scale(0);opacity:1}50%{transform:translate(-50%,-50%) scale(1.3);opacity:1}100%{transform:translate(-50%,-50%) scale(1);opacity:0}}

/* --- Responsive --- */
@media(max-width:400px){
  .card{width:44px;height:62px;font-size:1em;border-radius:6px}
  .pile .card{width:50px;height:70px;font-size:1.2em}
  h1{font-size:1.8em}
}

/* --- Fullscreen Button --- */
#fullscreen-btn{position:fixed;top:10px;right:10px;z-index:500;background:rgba(155,89,182,.7);border:none;color:#fff;border-radius:10px;padding:8px 12px;font-size:1.2em;cursor:pointer;backdrop-filter:blur(10px);min-height:42px;min-width:42px;line-height:1;transition:background .2s;box-shadow:0 2px 8px rgba(0,0,0,.3)}
#fullscreen-btn:hover,#fullscreen-btn:active{background:rgba(155,89,182,1)}

/* --- iOS Fullscreen Tip Banner --- */
#fs-tip{position:fixed;bottom:70px;left:50%;transform:translateX(-50%);background:rgba(26,26,46,.97);color:#fff;padding:14px 20px;border-radius:14px;font-size:.82em;z-index:600;text-align:center;max-width:300px;display:none;border:1px solid rgba(155,89,182,.4);box-shadow:0 4px 20px rgba(0,0,0,.5)}
#fs-tip button{padding:8px 16px;font-size:.85em;margin-top:10px}

/* --- Connection Status Banner --- */
#conn-status{position:fixed;top:60px;left:50%;transform:translateX(-50%);background:rgba(231,76,60,.9);color:#fff;padding:8px 20px;border-radius:20px;font-size:.8em;font-weight:600;z-index:400;display:none;gap:8px;align-items:center;backdrop-filter:blur(8px)}
#conn-status.show{display:flex}
#conn-status.reconnecting{background:rgba(243,156,18,.9)}
#conn-status.ok{background:rgba(46,204,113,.9)}
.conn-dot{width:8px;height:8px;border-radius:50%;background:#fff;animation:connBlink 1s infinite}
@keyframes connBlink{0%,100%{opacity:1}50%{opacity:.3}}

/* --- Notification Permission Banner --- */
#notif-banner{display:none;align-items:center;gap:10px;background:rgba(52,152,219,.15);border:1px solid rgba(52,152,219,.3);border-radius:12px;padding:10px 14px;margin:8px 0;max-width:400px;width:100%;font-size:.82em;color:#ccc}
#notif-banner button{padding:6px 14px;font-size:.82em;min-height:auto}

/* --- Action log --- */
#action-log{width:100%;max-width:700px;background:rgba(0,0,0,.2);border-radius:8px;padding:6px 12px;font-size:.72em;color:#888;margin-bottom:6px;min-height:24px;text-align:center;white-space:nowrap;overflow:hidden;text-overflow:ellipsis}

/* --- Disconnect overlay (mid-game) --- */
#disconnect-overlay{position:fixed;inset:0;background:rgba(0,0,0,.85);display:none;flex-direction:column;align-items:center;justify-content:center;z-index:450;gap:16px;padding:24px;text-align:center}
#disconnect-overlay.show{display:flex}
#disconnect-overlay h2{color:#e74c3c}
#disconnect-overlay p{color:#aaa;font-size:.9em}
.progress-ring{width:60px;height:60px}
.progress-ring-circle{stroke:#9b59b6;stroke-dasharray:157;stroke-dashoffset:157;stroke-linecap:round;transform-origin:50% 50%;transform:rotate(-90deg);transition:stroke-dashoffset 1s linear}
</style>
</head>
<body>

<!-- ============================================================
  UI OVERLAYS & FIXED ELEMENTS
============================================================ -->

<!-- Toast notification -->
<div class="toast" id="toast"></div>

<!-- Fullscreen button -->
<button id="fullscreen-btn" onclick="toggleFullscreen()" title="Plein √©cran">‚õ∂</button>

<!-- iOS fullscreen tip -->
<div id="fs-tip">
  <div>üì± <strong>iOS Safari</strong> ne supporte pas le plein √©cran natif.</div>
  <div style="margin-top:6px;color:#aaa">Appuyez sur <strong>‚ñ°‚Üë</strong> puis <em>"Sur l'√©cran d'accueil"</em></div>
  <div style="margin-top:10px;display:flex;justify-content:center;gap:8px">
    <button onclick="closeFsTip()">OK compris</button>
  </div>
</div>

<!-- Connection status banner (shown on disconnect/reconnect) -->
<div id="conn-status">
  <span class="conn-dot"></span>
  <span id="conn-status-text">Reconnexion...</span>
</div>

<!-- Boom animation overlay -->
<div class="boom-overlay" id="boom-overlay"></div>

<!-- Modal -->
<div class="modal-overlay" id="modal">
  <div class="modal">
    <h3 id="modal-title"></h3>
    <p id="modal-text"></p>
    <div class="btn-group" id="modal-buttons"></div>
  </div>
</div>

<!-- Disconnect overlay with countdown (mid-game host loss) -->
<div id="disconnect-overlay">
  <h2>‚ö†Ô∏è Connexion perdue</h2>
  <p id="disconnect-msg">L'h√¥te s'est d√©connect√©.</p>
  <svg class="progress-ring" viewBox="0 0 60 60">
    <circle cx="30" cy="30" r="25" fill="none" stroke="rgba(255,255,255,.1)" stroke-width="5"/>
    <circle class="progress-ring-circle" id="reconnect-ring" cx="30" cy="30" r="25" fill="none" stroke-width="5"/>
  </svg>
  <p id="reconnect-countdown" style="font-size:1.5em;font-weight:700;color:#bb86fc"></p>
  <button onclick="cancelReconnect()" class="secondary">Retour au menu</button>
</div>

<!-- ============================================================
  SCREENS
============================================================ -->

<!-- SCREEN: MENU -->
<div class="screen active" id="screen-menu">
  <h1>SKYJO</h1>
  <p class="subtitle">Jeu de cartes multijoueur V1.2.0</p>
  <div style="margin:12px 0;width:100%;max-width:320px">
    <input type="text" id="player-name" placeholder="Votre pseudo" maxlength="12" autocomplete="off">
  </div>
  <!-- Notification permission request -->
  <div id="notif-banner">
    <span>üîî Activer les notifications pour √™tre alert√© de votre tour ?</span>
    <button onclick="requestNotifPermission()">Activer</button>
    <button class="secondary" onclick="dismissNotifBanner()" style="padding:6px 10px;min-height:auto;font-size:.75em">Non merci</button>
  </div>
  <div class="btn-group" style="margin-top:8px">
    <button onclick="createGame()">Cr√©er une partie</button>
    <button class="secondary" onclick="showJoinScreen()">Rejoindre</button>
  </div>
  <div class="leaderboard-box" id="menu-leaderboard" style="margin-top:24px"></div>
</div>

<!-- SCREEN: JOIN -->
<div class="screen" id="screen-join">
  <h1>SKYJO</h1>
  <h2>Rejoindre une partie</h2>
  <div style="width:100%;max-width:320px">
    <input type="text" id="room-input" placeholder="Code de la salle" maxlength="6" autocomplete="off" style="text-transform:uppercase;text-align:center;font-size:1.4em;letter-spacing:4px">
  </div>
  <div class="btn-group">
    <button onclick="joinGame()">Rejoindre</button>
    <button class="secondary" onclick="showScreen('screen-menu')">Retour</button>
  </div>
</div>

<!-- SCREEN: LOBBY -->
<div class="screen" id="screen-lobby">
  <div class="lobby-box">
    <h2>Salle d'attente</h2>
    <p class="subtitle">Partagez le code ou le QR code</p>
    <div class="room-code" id="lobby-code"></div>
    <button class="copy-btn secondary" onclick="copyCode()">üìã Copier le lien</button>
    <div id="qr-container"></div>
    <ul class="lobby-players" id="lobby-players"></ul>
    <div class="btn-group">
      <button id="start-btn" onclick="startGame()" style="display:none">Lancer la partie</button>
      <button class="danger" onclick="leaveLobby()">Quitter</button>
    </div>
  </div>
</div>

<!-- SCREEN: GAME -->
<div class="screen" id="screen-game" style="justify-content:flex-start;padding-top:8px">
  <div class="game-header">
    <div class="round-info" id="round-info">Manche 1</div>
    <div class="game-status" id="game-status">En attente...</div>
    <button class="secondary" style="padding:6px 12px;font-size:.75em" onclick="showRules()">?</button>
  </div>
  <div id="action-log"></div>
  <div class="game-content" id="game-content">
    <div class="piles" id="piles-area"></div>
    <div class="players-area" id="players-area"></div>
  </div>
  <div class="action-bar" id="action-bar" style="display:none"></div>
</div>

<!-- SCREEN: ROUND REVEAL -->
<div class="screen" id="screen-round-reveal" style="justify-content:flex-start;padding-top:20px">
  <h2 style="margin-bottom:4px">üìä Fin de la manche</h2>
  <p class="subtitle" style="margin-bottom:12px" id="reveal-subtitle"></p>
  <div class="reveal-summary" id="reveal-summary"></div>
  <div class="btn-group" style="margin-top:18px">
    <button onclick="showRoundScoreTable()">Voir les scores ‚Üí</button>
  </div>
</div>

<!-- SCREEN: ROUND SCORES -->
<div class="screen" id="screen-round-scores" style="justify-content:flex-start;padding-top:24px">
  <div class="score-screen-content">
    <h2 style="margin-bottom:2px;align-self:flex-start">Scores ‚Äî Manche</h2>
    <p class="subtitle" style="margin-bottom:4px;align-self:flex-start" id="round-scores-subtitle"></p>
    <table class="scores-table" id="round-scores-table"></table>
    <div class="duration-badge" id="round-duration" style="display:none">‚è± <strong id="round-duration-value"></strong></div>
    <div class="btn-group" style="margin-top:16px;width:100%;justify-content:center">
      <button id="next-round-btn" onclick="nextRound()">Manche suivante ‚Üí</button>
    </div>
  </div>
</div>

<!-- SCREEN: FINAL SCORES -->
<div class="screen" id="screen-final-scores" style="justify-content:flex-start;padding-top:24px">
  <div class="score-screen-content">
    <h1 style="margin-bottom:6px">üèÜ Fin de partie</h1>
    <div id="final-winner-banner" class="winner-banner" style="width:100%"></div>
    <div id="final-score-cards" class="score-cards"></div>
    <div class="duration-badge" id="final-duration" style="display:none">‚è± Partie termin√©e en <strong id="final-duration-value"></strong></div>
    <div class="leaderboard-box" id="final-leaderboard"></div>
    <div class="btn-group" style="margin-top:16px;width:100%;justify-content:center">
      <button onclick="backToMenu()">Menu principal</button>
    </div>
  </div>
</div>

<!-- ============================================================
  JAVASCRIPT
============================================================ -->
<script>
'use strict';

// ============================================================
// SECTION 1 ‚Äî CONSTANTS & CONFIGURATION
// ============================================================

const CARD_COUNTS = {'-2':5,'-1':10,'0':15,'1':10,'2':10,'3':10,'4':10,'5':10,'6':10,'7':10,'8':10,'9':10,'10':10,'11':10,'12':10};
const ROWS = 3, COLS = 4;
const MAX_PLAYERS = 8;
const END_SCORE = 100;

// ICE servers: STUN (discovery) + TURN (relay for restrictive NATs)
// IMPROVEMENT: Added free TURN servers for better connectivity on mobile/corporate networks
const ICE_SERVERS = [
  { urls: 'stun:stun.l.google.com:19302' },
  { urls: 'stun:stun1.l.google.com:19302' },
  { urls: 'stun:openrelay.metered.ca:80' },
  {
    urls: 'turn:openrelay.metered.ca:80',
    username: 'openrelayproject',
    credential: 'openrelayproject'
  },
  {
    urls: 'turn:openrelay.metered.ca:443',
    username: 'openrelayproject',
    credential: 'openrelayproject'
  },
  {
    urls: 'turn:openrelay.metered.ca:443?transport=tcp',
    username: 'openrelayproject',
    credential: 'openrelayproject'
  }
];

const RECONNECT_TIMEOUT_MS = 12000; // 12 seconds before giving up reconnect


// ============================================================
// SECTION 2 ‚Äî APPLICATION STATE
// ============================================================

let peer = null;
let connections = {};   // host only: peerId ‚Üí PeerJS connection
let hostConn = null;    // client only: connection to host
let isHost = false;
let myPeerId = '';
let myName = '';
let roomCode = '';
let gameState = null;
let myPlayerId = '';
let currentScreen = 'screen-menu';

// Reconnection state
// IMPROVEMENT: Track reconnection attempts and timeout
let reconnectTimer = null;
let reconnectCountdownInterval = null;
let reconnectDeadline = null;
let cancelledReconnect = false;

// Audio context (lazy init on first user gesture)
// IMPROVEMENT: Sound feedback for game events
let audioCtx = null;

// Action log history
// IMPROVEMENT: Show recent actions to all players
let actionLogHistory = [];


// ============================================================
// SECTION 3 ‚Äî PERSISTENT LEADERBOARD (localStorage)
// ============================================================

function getLeaderboard() {
  try {
    return JSON.parse(localStorage.getItem('skyjo_leaderboard') || '{}');
  } catch(e) { return {}; }
}

function saveLeaderboard(lb) {
  try { localStorage.setItem('skyjo_leaderboard', JSON.stringify(lb)); } catch(e) {}
}

function updateLeaderboard(playerName, won) {
  const lb = getLeaderboard();
  if (!lb[playerName]) lb[playerName] = { wins: 0, games: 0 };
  lb[playerName].games++;
  if (won) lb[playerName].wins++;
  saveLeaderboard(lb);
}

function renderLeaderboard(containerId) {
  const lb = getLeaderboard();
  const container = document.getElementById(containerId);
  if (!container) return;
  const entries = Object.entries(lb).sort((a, b) => b[1].wins - a[1].wins || a[1].games - b[1].games);
  if (entries.length === 0) {
    container.innerHTML = '<h3>üèÜ Classement</h3><p style="color:#666;font-size:.85em;text-align:center">Aucune partie termin√©e</p>';
    return;
  }
  let html = '<h3>üèÜ Classement persistant</h3>';
  entries.slice(0, 10).forEach(([name, data], i) => {
    const rank = i === 0 ? 'ü•á' : i === 1 ? 'ü•à' : i === 2 ? 'ü•â' : (i + 1);
    html += `<div class="lb-row">
      <span class="lb-rank">${rank}</span>
      <span class="lb-name">${name}</span>
      <span class="lb-wins">${data.wins}W</span>
      <span class="lb-games">${data.games}G</span>
    </div>`;
  });
  container.innerHTML = html;
}


// ============================================================
// SECTION 4 ‚Äî AUDIO (Web Audio API)
// IMPROVEMENT: Sound feedback for key game events
// ============================================================

function ensureAudio() {
  if (!audioCtx) {
    try { audioCtx = new (window.AudioContext || window.webkitAudioContext)(); } catch(e) {}
  }
  if (audioCtx && audioCtx.state === 'suspended') audioCtx.resume();
}

function playTone(frequency, duration, type = 'sine', volume = 0.15) {
  ensureAudio();
  if (!audioCtx) return;
  try {
    const osc = audioCtx.createOscillator();
    const gain = audioCtx.createGain();
    osc.connect(gain);
    gain.connect(audioCtx.destination);
    osc.type = type;
    osc.frequency.setValueAtTime(frequency, audioCtx.currentTime);
    gain.gain.setValueAtTime(volume, audioCtx.currentTime);
    gain.gain.exponentialRampToValueAtTime(0.001, audioCtx.currentTime + duration);
    osc.start();
    osc.stop(audioCtx.currentTime + duration);
  } catch(e) {}
}

function playCardFlip() {
  playTone(800, 0.06, 'square', 0.08);
  setTimeout(() => playTone(600, 0.08, 'square', 0.05), 50);
}

function playMyTurnSound() {
  // Ascending two-note chime
  playTone(523, 0.15, 'sine', 0.18);
  setTimeout(() => playTone(659, 0.25, 'sine', 0.18), 130);
}

function playColumnElimSound() {
  [392, 523, 659, 784].forEach((f, i) => setTimeout(() => playTone(f, 0.2, 'square', 0.12), i * 80));
}

function playErrorSound() {
  playTone(200, 0.15, 'sawtooth', 0.1);
}


// ============================================================
// SECTION 5 ‚Äî NOTIFICATIONS (Web Notifications API)
// IMPROVEMENT: Browser notifications when it's your turn (tab in background)
// ============================================================

function checkNotifBanner() {
  if ('Notification' in window && Notification.permission === 'default') {
    const dismissed = localStorage.getItem('skyjo_notif_dismissed');
    if (!dismissed) {
      document.getElementById('notif-banner').style.display = 'flex';
    }
  }
}

function requestNotifPermission() {
  document.getElementById('notif-banner').style.display = 'none';
  Notification.requestPermission().then(result => {
    if (result === 'granted') toast('üîî Notifications activ√©es !');
  });
}

function dismissNotifBanner() {
  document.getElementById('notif-banner').style.display = 'none';
  localStorage.setItem('skyjo_notif_dismissed', '1');
}

function sendTurnNotification() {
  if (!('Notification' in window) || Notification.permission !== 'granted') return;
  if (document.visibilityState === 'visible') return; // Only when tab is in background
  try {
    new Notification('üÉè Skyjo ‚Äî √Ä vous de jouer !', {
      body: 'C\'est votre tour dans la partie Skyjo.',
      icon: 'https://public-frontend-cos.metadl.com/mgx/img/favicon_atoms.ico',
      tag: 'skyjo-turn' // Replaces previous notification
    });
  } catch(e) {}
}

function vibrateIfMobile() {
  // IMPROVEMENT: Haptic feedback on mobile when it's your turn
  if ('vibrate' in navigator) {
    try { navigator.vibrate([100, 50, 100]); } catch(e) {}
  }
}


// ============================================================
// SECTION 6 ‚Äî ACTION LOG
// IMPROVEMENT: Show recent game actions to all players
// ============================================================

function pushLog(msg) {
  actionLogHistory.unshift(msg);
  if (actionLogHistory.length > 3) actionLogHistory.pop();
  renderLog();
}

function renderLog() {
  const el = document.getElementById('action-log');
  if (!el) return;
  el.textContent = actionLogHistory[0] || '';
}

function clearLog() {
  actionLogHistory = [];
  renderLog();
}


// ============================================================
// SECTION 7 ‚Äî VISUAL EFFECTS
// ============================================================

function triggerBoom() {
  const overlay = document.getElementById('boom-overlay');
  overlay.innerHTML = '';
  const colors = ['#f1c40f', '#e74c3c', '#e67e22', '#9b59b6', '#2ecc71', '#3498db'];
  for (let i = 0; i < 30; i++) {
    const p = document.createElement('div');
    p.className = 'boom-particle';
    const size = 6 + Math.random() * 12;
    const angle = Math.random() * Math.PI * 2;
    const dist = 80 + Math.random() * 200;
    p.style.cssText = `width:${size}px;height:${size}px;background:${colors[Math.floor(Math.random() * colors.length)]};left:50%;top:50%;--dx:${Math.cos(angle) * dist}px;--dy:${Math.sin(angle) * dist}px;`;
    overlay.appendChild(p);
  }
  const txt = document.createElement('div');
  txt.className = 'boom-text';
  txt.textContent = 'üí• BOOM!';
  overlay.appendChild(txt);
  setTimeout(() => { overlay.innerHTML = ''; }, 1000);
}


// ============================================================
// SECTION 8 ‚Äî FULLSCREEN
// ============================================================

const isIOS = /iPad|iPhone|iPod/.test(navigator.userAgent) && !window.MSStream;
const isAndroid = /Android/.test(navigator.userAgent);
const isMobile = isIOS || isAndroid || ('ontouchstart' in window);

function toggleFullscreen() {
  const btn = document.getElementById('fullscreen-btn');
  if (isIOS) {
    const tip = document.getElementById('fs-tip');
    tip.style.display = tip.style.display === 'block' ? 'none' : 'block';
    return;
  }
  const isFs = !!(document.fullscreenElement || document.webkitFullscreenElement || document.mozFullScreenElement);
  if (!isFs) {
    const el = document.documentElement;
    const req = el.requestFullscreen || el.webkitRequestFullscreen || el.mozRequestFullScreen || el.msRequestFullscreen;
    if (req) {
      req.call(el).then(() => {
        btn.textContent = '‚úï';
        btn.title = 'Quitter le plein √©cran';
        try { screen.orientation?.lock?.('portrait'); } catch(e) {}
      }).catch(() => toast('Plein √©cran non disponible'));
    } else {
      toast('Plein √©cran non support√© sur ce navigateur');
    }
  } else {
    const exit = document.exitFullscreen || document.webkitExitFullscreen || document.mozCancelFullScreen;
    if (exit) exit.call(document);
    btn.textContent = '‚õ∂';
    btn.title = 'Plein √©cran';
  }
}

function closeFsTip() {
  document.getElementById('fs-tip').style.display = 'none';
}

['fullscreenchange', 'webkitfullscreenchange', 'mozfullscreenchange'].forEach(ev => {
  document.addEventListener(ev, () => {
    const btn = document.getElementById('fullscreen-btn');
    const isFs = !!(document.fullscreenElement || document.webkitFullscreenElement || document.mozFullScreenElement);
    btn.textContent = isFs ? '‚úï' : '‚õ∂';
    btn.title = isFs ? 'Quitter le plein √©cran' : 'Plein √©cran';
  });
});

window.addEventListener('load', () => {
  if (isIOS) {
    document.getElementById('fullscreen-btn').textContent = 'üì±';
    document.getElementById('fullscreen-btn').title = 'Plein √©cran (aide)';
    if (!localStorage.getItem('skyjo_fs_tip_shown')) {
      setTimeout(() => {
        document.getElementById('fs-tip').style.display = 'block';
        localStorage.setItem('skyjo_fs_tip_shown', '1');
      }, 1500);
    }
  }
  // Init leaderboard & notification banner on menu
  renderLeaderboard('menu-leaderboard');
  checkNotifBanner();
});


// ============================================================
// SECTION 9 ‚Äî NETWORK: PEER SETUP & CONNECTION
// IMPROVEMENT: TURN servers added; connection timeout; reconnection support
// ============================================================

function generateRoomCode() {
  const chars = 'ABCDEFGHJKLMNPQRSTUVWXYZ23456789';
  let code = '';
  for (let i = 0; i < 5; i++) code += chars[Math.floor(Math.random() * chars.length)];
  return code;
}

function initPeer(id) {
  return new Promise((resolve, reject) => {
    peer = new Peer(id, {
      config: { iceServers: ICE_SERVERS }
    });
    const timeout = setTimeout(() => {
      reject(new Error('D√©lai de connexion d√©pass√©. V√©rifiez votre r√©seau.'));
    }, 10000);
    peer.on('open', (pid) => {
      clearTimeout(timeout);
      myPeerId = pid;
      resolve(pid);
    });
    peer.on('error', (err) => {
      clearTimeout(timeout);
      console.error('Peer error:', err);
      if (err.type === 'unavailable-id') reject(new Error('Code d√©j√† utilis√©'));
      else reject(err);
    });
  });
}

// IMPROVEMENT: Show connection status UI
function showConnStatus(type, msg) {
  const el = document.getElementById('conn-status');
  const txt = document.getElementById('conn-status-text');
  el.className = 'show ' + type;
  txt.textContent = msg;
}

function hideConnStatus() {
  document.getElementById('conn-status').className = '';
}


// ============================================================
// SECTION 10 ‚Äî NETWORK: RECONNECTION
// IMPROVEMENT: Automatic reconnect attempt with countdown UI when host drops
// ============================================================

function startReconnectFlow(hostPeerId) {
  cancelledReconnect = false;
  reconnectDeadline = Date.now() + RECONNECT_TIMEOUT_MS;
  document.getElementById('disconnect-overlay').classList.add('show');
  document.getElementById('disconnect-msg').textContent = 'Tentative de reconnexion en cours...';
  showConnStatus('reconnecting', 'Reconnexion...');

  const ring = document.getElementById('reconnect-ring');
  const circumference = 157; // 2 * PI * 25

  reconnectCountdownInterval = setInterval(() => {
    if (cancelledReconnect) return;
    const remaining = Math.max(0, reconnectDeadline - Date.now());
    const secondsLeft = Math.ceil(remaining / 1000);
    document.getElementById('reconnect-countdown').textContent = secondsLeft + 's';
    const progress = remaining / RECONNECT_TIMEOUT_MS;
    ring.style.strokeDashoffset = circumference * (1 - progress);

    if (remaining <= 0) {
      clearInterval(reconnectCountdownInterval);
      finishReconnectFail();
    }
  }, 200);

  // Try to reconnect
  attemptReconnect(hostPeerId);
}

function attemptReconnect(hostPeerId) {
  if (cancelledReconnect) return;
  const newConn = peer.connect(hostPeerId, { reliable: true });

  newConn.on('open', () => {
    if (cancelledReconnect) return;
    hostConn = newConn;
    hostConn.send({ type: 'join', name: myName, id: myPeerId });
    hostConn.on('data', (data) => handleClientMessage(data));
    hostConn.on('close', () => handleHostDisconnect(hostPeerId));
    clearInterval(reconnectCountdownInterval);
    document.getElementById('disconnect-overlay').classList.remove('show');
    hideConnStatus();
    toast('‚úÖ Reconnect√© !');
  });

  newConn.on('error', () => {
    if (cancelledReconnect || Date.now() >= reconnectDeadline) return;
    setTimeout(() => attemptReconnect(hostPeerId), 2000);
  });
}

function finishReconnectFail() {
  document.getElementById('disconnect-overlay').classList.remove('show');
  hideConnStatus();
  toast('Connexion perdue. Retour au menu.');
  backToMenu();
}

function cancelReconnect() {
  cancelledReconnect = true;
  clearInterval(reconnectCountdownInterval);
  document.getElementById('disconnect-overlay').classList.remove('show');
  hideConnStatus();
  backToMenu();
}

function handleHostDisconnect(hostPeerId) {
  if (currentScreen === 'screen-menu') return;
  showConnStatus('reconnecting', 'Connexion perdue...');
  startReconnectFlow(hostPeerId);
}


// ============================================================
// SECTION 11 ‚Äî NETWORK: HOST LOGIC
// ============================================================

function handleHostMessage(conn, data) {
  if (!gameState) return;

  // SECURITY IMPROVEMENT: Validate that the sender is who they claim to be
  // The conn.peer is the trusted PeerJS peer ID ‚Äî we verify it matches the claimed playerId
  switch(data.type) {
    case 'join':
      if (gameState.phase !== 'lobby') {
        conn.send({ type: 'error', msg: 'Partie d√©j√† en cours' });
        return;
      }
      if (gameState.players.length >= MAX_PLAYERS) {
        conn.send({ type: 'error', msg: 'Salle pleine' });
        return;
      }
      connections[data.id] = conn;
      gameState.players.push({ id: data.id, name: data.name, isHost: false });
      gameState.totalScores[data.id] = 0;
      broadcastState();
      broadcastToast(data.name + ' a rejoint la salle');
      break;

    case 'action':
      // SECURITY: Verify that the playerId in the action matches the actual connection
      if (data.playerId !== conn.peer) {
        console.warn('Security: action playerId mismatch', data.playerId, conn.peer);
        return;
      }
      handlePlayerAction(data.playerId, data.action);
      break;
  }
}

function handleDisconnect(peerId) {
  if (!gameState) return;
  delete connections[peerId];
  if (gameState.phase === 'lobby') {
    const p = gameState.players.find(pl => pl.id === peerId);
    if (p) broadcastToast(p.name + ' a quitt√© la salle');
    gameState.players = gameState.players.filter(p => p.id !== peerId);
    delete gameState.totalScores[peerId];
    broadcastState();
  }
  // Mid-game disconnects: state broadcast will show missing player
  // (host migration is complex; we log but don't crash the game)
}


// ============================================================
// SECTION 12 ‚Äî NETWORK: CLIENT LOGIC
// ============================================================

function handleClientMessage(data) {
  switch(data.type) {
    case 'state':
      gameState = data.state;
      renderFromState();
      break;
    case 'error':
      toast(data.msg);
      playErrorSound();
      break;
    case 'toast':
      toast(data.msg);
      break;
    case 'boom':
      triggerBoom();
      playColumnElimSound();
      break;
    case 'log':
      // IMPROVEMENT: Sync action log across all clients
      pushLog(data.msg);
      break;
  }
}


// ============================================================
// SECTION 13 ‚Äî NETWORK: BROADCAST HELPERS
// ============================================================

function broadcastState() {
  const msg = { type: 'state', state: gameState };
  Object.values(connections).forEach(conn => {
    try { conn.send(msg); } catch(e) {}
  });
  renderFromState();
}

function broadcastToast(msg) {
  Object.values(connections).forEach(conn => {
    try { conn.send({ type: 'toast', msg }); } catch(e) {}
  });
  toast(msg);
}

function broadcastBoom() {
  Object.values(connections).forEach(conn => {
    try { conn.send({ type: 'boom' }); } catch(e) {}
  });
  triggerBoom();
  playColumnElimSound();
}

// IMPROVEMENT: Broadcast log messages to all clients
function broadcastLog(msg) {
  Object.values(connections).forEach(conn => {
    try { conn.send({ type: 'log', msg }); } catch(e) {}
  });
  pushLog(msg);
}

function sendToHost(data) {
  if (hostConn && hostConn.open) {
    hostConn.send(data);
  }
}


// ============================================================
// SECTION 14 ‚Äî MENU & NAVIGATION
// ============================================================

function getName() {
  let name = document.getElementById('player-name').value.trim();
  if (!name) name = 'Joueur' + Math.floor(Math.random() * 999);
  return name;
}

function showScreen(id) {
  document.querySelectorAll('.screen').forEach(s => s.classList.remove('active'));
  document.getElementById(id).classList.add('active');
  currentScreen = id;
  if (id === 'screen-menu') renderLeaderboard('menu-leaderboard');
}

function showJoinScreen() {
  myName = getName();
  showScreen('screen-join');
  document.getElementById('room-input').focus();
}

// IMPROVEMENT: Warn before leaving if a game is in progress
window.addEventListener('beforeunload', (e) => {
  if (gameState && gameState.phase !== 'lobby' && gameState.phase !== 'game_over') {
    e.preventDefault();
    e.returnValue = 'Quitter la partie en cours ?';
    return e.returnValue;
  }
});


// ============================================================
// SECTION 15 ‚Äî GAME CREATION & JOINING
// ============================================================

async function createGame() {
  ensureAudio(); // Init AudioContext on user gesture
  myName = getName();
  roomCode = generateRoomCode();
  isHost = true;

  showConnStatus('reconnecting', 'Cr√©ation de la salle...');

  try {
    await initPeer('skyjo-' + roomCode);
  } catch(e) {
    hideConnStatus();
    toast('Erreur: ' + e.message);
    return;
  }

  hideConnStatus();
  myPlayerId = myPeerId;

  peer.on('connection', (conn) => {
    conn.on('open', () => {
      conn.on('data', (data) => handleHostMessage(conn, data));
    });
    conn.on('close', () => handleDisconnect(conn.peer));
  });

  gameState = {
    phase: 'lobby',
    players: [{ id: myPeerId, name: myName, isHost: true }],
    round: 0,
    totalScores: {}
  };
  gameState.totalScores[myPeerId] = 0;

  showLobby();
}

async function joinGame() {
  ensureAudio();
  myName = getName();
  const code = document.getElementById('room-input').value.trim().toUpperCase();
  if (!code) { toast('Entrez un code'); return; }
  roomCode = code;
  isHost = false;

  showConnStatus('reconnecting', 'Connexion en cours...');

  try {
    await initPeer('skyjo-' + roomCode + '-' + Math.random().toString(36).substr(2, 4));
  } catch(e) {
    hideConnStatus();
    toast('Erreur connexion: ' + e.message);
    return;
  }

  myPlayerId = myPeerId;
  const hostId = 'skyjo-' + roomCode;
  hostConn = peer.connect(hostId, { reliable: true });

  // IMPROVEMENT: Explicit timeout instead of a bare setTimeout
  const joinTimeout = setTimeout(() => {
    if (currentScreen !== 'screen-lobby') {
      hideConnStatus();
      toast('Impossible de rejoindre (timeout). V√©rifiez le code.');
    }
  }, 8000);

  hostConn.on('open', () => {
    clearTimeout(joinTimeout);
    hideConnStatus();
    hostConn.send({ type: 'join', name: myName, id: myPeerId });
    hostConn.on('data', (data) => handleClientMessage(data));
    showLobbyAsClient();
  });

  hostConn.on('close', () => {
    clearTimeout(joinTimeout);
    handleHostDisconnect(hostId);
  });

  hostConn.on('error', (err) => {
    clearTimeout(joinTimeout);
    hideConnStatus();
    toast('Impossible de rejoindre. V√©rifiez le code.');
    console.error(err);
  });
}

function showLobbyAsClient() {
  showScreen('screen-lobby');
  document.getElementById('lobby-code').textContent = roomCode;
  generateQR();
}


// ============================================================
// SECTION 16 ‚Äî LOBBY
// ============================================================

function showLobby() {
  showScreen('screen-lobby');
  document.getElementById('lobby-code').textContent = roomCode;
  generateQR();
  renderLobby();
}

function generateQR() {
  const url = window.location.href.split('?')[0] + '?room=' + roomCode;
  const container = document.getElementById('qr-container');
  container.innerHTML = '';
  try {
    new QRCode(container, {
      text: url,
      width: 180,
      height: 180,
      colorDark: '#1a1a2e',
      colorLight: '#ffffff',
      correctLevel: QRCode.CorrectLevel.M
    });
  } catch(e) {
    container.innerHTML = '<p style="color:#333;font-size:.75em;padding:8px;word-break:break-all">' + url + '</p>';
  }
}

function renderLobby() {
  if (!gameState) return;
  const list = document.getElementById('lobby-players');
  list.innerHTML = gameState.players.map(p =>
    `<li>${p.name} ${p.isHost ? '<span class="host-badge">H√îTE</span>' : ''}${p.id === myPlayerId ? ' <span style="color:#888;font-size:.8em">(vous)</span>' : ''}</li>`
  ).join('');
  const startBtn = document.getElementById('start-btn');
  startBtn.style.display = (isHost && gameState.players.length >= 2) ? '' : 'none';
}

function copyCode() {
  const url = window.location.href.split('?')[0] + '?room=' + roomCode;
  navigator.clipboard.writeText(url).then(() => toast('Lien copi√© !')).catch(() => toast(roomCode));
}

function leaveLobby() {
  if (peer) peer.destroy();
  peer = null;
  connections = {};
  hostConn = null;
  gameState = null;
  backToMenu();
}

function backToMenu() {
  clearInterval(reconnectCountdownInterval);
  if (peer) { peer.destroy(); peer = null; }
  connections = {};
  hostConn = null;
  gameState = null;
  isHost = false;
  clearLog();
  hideConnStatus();
  document.getElementById('disconnect-overlay').classList.remove('show');
  showScreen('screen-menu');
}


// ============================================================
// SECTION 17 ‚Äî GAME LOGIC: DECK
// ============================================================

function createDeck() {
  const deck = [];
  for (const [val, count] of Object.entries(CARD_COUNTS)) {
    for (let i = 0; i < count; i++) {
      deck.push(parseInt(val));
    }
  }
  return shuffle(deck);
}

function shuffle(arr) {
  const a = [...arr];
  for (let i = a.length - 1; i > 0; i--) {
    const j = Math.floor(Math.random() * (i + 1));
    [a[i], a[j]] = [a[j], a[i]];
  }
  return a;
}

function reshuffleDeck() {
  if (gameState.discard.length <= 1) return;
  const top = gameState.discard.pop();
  gameState.deck = shuffle(gameState.discard);
  gameState.discard = [top];
  broadcastToast('Pioche m√©lang√©e depuis la d√©fausse');
}


// ============================================================
// SECTION 18 ‚Äî GAME LOGIC: ROUND INIT
// ============================================================

function startGame() {
  if (!isHost || gameState.players.length < 2) return;
  gameState.gameStartTime = Date.now();
  initRound();
}

function initRound() {
  const deck = createDeck();
  const hands = {};
  const revealed = {};
  clearLog();

  gameState.players.forEach(p => {
    const cards = [];
    for (let r = 0; r < ROWS; r++) {
      const row = [];
      for (let c = 0; c < COLS; c++) { row.push(deck.pop()); }
      cards.push(row);
    }
    hands[p.id] = cards;
    const rev = [];
    for (let r = 0; r < ROWS; r++) { rev.push([false, false, false, false]); }
    revealed[p.id] = rev;
  });

  const discardTop = deck.pop();

  gameState.round++;
  gameState.phase = 'reveal_initial';
  gameState.deck = deck;
  gameState.discard = [discardTop];
  gameState.hands = hands;
  gameState.revealed = revealed;
  gameState.eliminated = {};
  gameState.players.forEach(p => { gameState.eliminated[p.id] = [false, false, false, false]; });
  gameState.currentPlayerIndex = -1;
  gameState.initialReveals = {};
  gameState.players.forEach(p => { gameState.initialReveals[p.id] = 0; });
  gameState.turnPhase = null;
  gameState.drawnCard = null;
  gameState.drawnFrom = null;
  gameState.drawnByPlayerId = null;
  gameState.lastRoundTriggeredBy = null;
  gameState.lastRoundTurnsLeft = -1;
  gameState.roundScores = {};

  broadcastToast('Manche ' + gameState.round + ' ‚Äî Retournez 2 cartes !');
  broadcastState();
}


// ============================================================
// SECTION 19 ‚Äî GAME LOGIC: PLAYER ACTIONS
// ============================================================

// Route action to host or directly if we are host
function performAction(action) {
  ensureAudio();
  if (isHost) {
    handlePlayerAction(myPlayerId, action);
  } else {
    sendToHost({ type: 'action', playerId: myPlayerId, action });
  }
}

function handlePlayerAction(playerId, action) {
  if (!isHost || !gameState) return;
  switch(gameState.phase) {
    case 'reveal_initial': handleRevealInitial(playerId, action); break;
    case 'playing': handlePlayingAction(playerId, action); break;
  }
}

function handleRevealInitial(playerId, action) {
  if (action.type !== 'reveal') return;
  const { row, col } = action;
  if (gameState.revealed[playerId][row][col]) return;
  if (gameState.eliminated[playerId][col]) return;
  if (gameState.initialReveals[playerId] >= 2) return;

  gameState.revealed[playerId][row][col] = true;
  gameState.initialReveals[playerId]++;

  const val = gameState.hands[playerId][row][col];
  const pName = getPlayerName(playerId);
  broadcastLog(`${pName} retourne un ${val}`);

  const allDone = gameState.players.every(p => gameState.initialReveals[p.id] >= 2);
  if (allDone) {
    let maxSum = -Infinity, startIdx = 0;
    gameState.players.forEach((p, idx) => {
      let sum = 0;
      for (let r = 0; r < ROWS; r++) {
        for (let c = 0; c < COLS; c++) {
          if (gameState.revealed[p.id][r][c]) sum += gameState.hands[p.id][r][c];
        }
      }
      if (sum > maxSum) { maxSum = sum; startIdx = idx; }
    });
    gameState.currentPlayerIndex = startIdx;
    gameState.phase = 'playing';
    gameState.turnPhase = 'draw';
    broadcastToast(gameState.players[startIdx].name + ' commence !');
  }
  broadcastState();
}

function handlePlayingAction(playerId, action) {
  const currentPlayer = gameState.players[gameState.currentPlayerIndex];
  if (playerId !== currentPlayer.id) return;

  const pName = getPlayerName(playerId);

  switch(action.type) {
    case 'draw_deck':
      if (gameState.turnPhase !== 'draw') return;
      if (gameState.deck.length === 0) reshuffleDeck();
      gameState.drawnCard = gameState.deck.pop();
      gameState.drawnFrom = 'deck';
      gameState.drawnByPlayerId = playerId;
      gameState.turnPhase = 'drawn_from_pile';
      broadcastLog(`${pName} pioche depuis la pioche`);
      broadcastState();
      break;

    case 'draw_discard':
      if (gameState.turnPhase !== 'draw') return;
      if (gameState.discard.length === 0) return;
      gameState.drawnCard = gameState.discard.pop();
      gameState.drawnFrom = 'discard';
      gameState.drawnByPlayerId = playerId;
      gameState.turnPhase = 'place_mandatory';
      broadcastLog(`${pName} prend le ${gameState.drawnCard} sur la d√©fausse`);
      broadcastState();
      break;

    case 'place_card': {
      if (gameState.turnPhase !== 'drawn_from_pile' && gameState.turnPhase !== 'place_mandatory') return;
      const { row, col } = action;
      if (gameState.eliminated[playerId][col]) return;
      const oldCard = gameState.hands[playerId][row][col];
      const placed = gameState.drawnCard;
      gameState.hands[playerId][row][col] = placed;
      gameState.revealed[playerId][row][col] = true;
      gameState.discard.push(oldCard);
      gameState.drawnCard = null;
      gameState.drawnByPlayerId = null;
      broadcastLog(`${pName} place le ${placed} (d√©fausse le ${oldCard})`);
      checkColumnElimination(playerId);
      endTurn();
      break;
    }

    case 'discard_drawn':
      if (gameState.turnPhase !== 'drawn_from_pile') return;
      broadcastLog(`${pName} d√©fausse le ${gameState.drawnCard}`);
      gameState.discard.push(gameState.drawnCard);
      gameState.drawnCard = null;
      gameState.drawnByPlayerId = null;
      gameState.turnPhase = 'must_reveal';
      broadcastState();
      break;

    case 'reveal_card': {
      if (gameState.turnPhase !== 'must_reveal') return;
      const rr = action.row, rc = action.col;
      if (gameState.revealed[playerId][rr][rc]) return;
      if (gameState.eliminated[playerId][rc]) return;
      gameState.revealed[playerId][rr][rc] = true;
      const revVal = gameState.hands[playerId][rr][rc];
      broadcastLog(`${pName} retourne un ${revVal}`);
      checkColumnElimination(playerId);
      endTurn();
      break;
    }
  }
}


// ============================================================
// SECTION 20 ‚Äî GAME LOGIC: COLUMN ELIMINATION & TURN FLOW
// ============================================================

function checkColumnElimination(playerId) {
  for (let c = 0; c < COLS; c++) {
    if (gameState.eliminated[playerId][c]) continue;
    let allRevealed = true, allSame = true, val = null;
    for (let r = 0; r < ROWS; r++) {
      if (!gameState.revealed[playerId][r][c]) { allRevealed = false; break; }
      if (val === null) val = gameState.hands[playerId][r][c];
      else if (gameState.hands[playerId][r][c] !== val) allSame = false;
    }
    if (allRevealed && allSame) {
      gameState.eliminated[playerId][c] = true;
      for (let r = 0; r < ROWS; r++) { gameState.discard.push(gameState.hands[playerId][r][c]); }
      const msg = `${getPlayerName(playerId)} √©limine une colonne de ${val} !`;
      broadcastLog(msg);
      broadcastToast(msg);
      broadcastBoom();
    }
  }
}

function endTurn() {
  const playerId = gameState.players[gameState.currentPlayerIndex].id;
  if (gameState.lastRoundTriggeredBy === null) {
    const allRevealed = isAllRevealed(playerId);
    if (allRevealed) {
      gameState.lastRoundTriggeredBy = playerId;
      gameState.lastRoundTurnsLeft = gameState.players.length - 1;
      const msg = `${getPlayerName(playerId)} a tout r√©v√©l√© ! Dernier tour !`;
      broadcastLog(msg);
      broadcastToast(msg);
    }
  }
  if (gameState.lastRoundTriggeredBy !== null) {
    gameState.lastRoundTurnsLeft--;
    if (gameState.lastRoundTurnsLeft <= 0) {
      endRound();
      return;
    }
  }
  advancePlayer();
  gameState.turnPhase = 'draw';
  gameState.drawnCard = null;
  gameState.drawnFrom = null;
  gameState.drawnByPlayerId = null;
  broadcastState();
}

function advancePlayer() {
  gameState.currentPlayerIndex = (gameState.currentPlayerIndex + 1) % gameState.players.length;
}

function isAllRevealed(playerId) {
  for (let r = 0; r < ROWS; r++) {
    for (let c = 0; c < COLS; c++) {
      if (gameState.eliminated[playerId][c]) continue;
      if (!gameState.revealed[playerId][r][c]) return false;
    }
  }
  return true;
}

function getPlayerName(id) {
  const p = gameState.players.find(pl => pl.id === id);
  return p ? p.name : '?';
}


// ============================================================
// SECTION 21 ‚Äî GAME LOGIC: END OF ROUND & GAME
// ============================================================

function endRound() {
  gameState.players.forEach(p => {
    for (let r = 0; r < ROWS; r++) {
      for (let c = 0; c < COLS; c++) { gameState.revealed[p.id][r][c] = true; }
    }
  });

  const scores = {};
  gameState.players.forEach(p => {
    let sum = 0;
    for (let r = 0; r < ROWS; r++) {
      for (let c = 0; c < COLS; c++) {
        if (!gameState.eliminated[p.id][c]) sum += gameState.hands[p.id][r][c];
      }
    }
    scores[p.id] = sum;
  });

  const trigId = gameState.lastRoundTriggeredBy;
  if (trigId) {
    const trigScore = scores[trigId];
    const minOther = Math.min(...gameState.players.filter(p => p.id !== trigId).map(p => scores[p.id]));
    if (trigScore >= minOther) {
      scores[trigId] *= 2;
      const msg = `${getPlayerName(trigId)} n'a pas le score le plus bas ‚Äî score doubl√© !`;
      broadcastLog(msg);
      broadcastToast(msg);
    }
  }

  gameState.roundScores = scores;
  gameState.players.forEach(p => {
    gameState.totalScores[p.id] = (gameState.totalScores[p.id] || 0) + scores[p.id];
  });

  const gameOver = gameState.players.some(p => gameState.totalScores[p.id] >= END_SCORE);
  gameState.phase = gameOver ? 'game_over_reveal' : 'round_reveal';
  gameState.drawnCard = null;
  gameState.drawnByPlayerId = null;
  broadcastState();
}

function nextRound() {
  if (!isHost) return;
  initRound();
}


// ============================================================
// SECTION 22 ‚Äî RENDERING: STATE ROUTER
// ============================================================

// Track previous "my turn" state to trigger sound/notification only on change
let _wasMyTurnLastRender = false;

function renderFromState() {
  if (!gameState) return;

  switch(gameState.phase) {
    case 'lobby':
      showScreen('screen-lobby');
      document.getElementById('lobby-code').textContent = roomCode;
      renderLobby();
      break;
    case 'reveal_initial':
    case 'playing':
      showScreen('screen-game');
      renderGame();
      break;
    case 'round_reveal':
      showScreen('screen-round-reveal');
      renderRoundReveal(false);
      break;
    case 'game_over_reveal':
      showScreen('screen-round-reveal');
      renderRoundReveal(true);
      break;
    case 'round_end':
      showScreen('screen-round-scores');
      renderRoundScores();
      break;
    case 'game_over':
      showScreen('screen-final-scores');
      renderFinalScores();
      break;
  }
}


// ============================================================
// SECTION 23 ‚Äî RENDERING: GAME SCREEN
// ============================================================

function renderGame() {
  const pilesArea = document.getElementById('piles-area');
  const playersArea = document.getElementById('players-area');
  const actionBar = document.getElementById('action-bar');
  const statusEl = document.getElementById('game-status');
  const roundEl = document.getElementById('round-info');

  roundEl.textContent = 'Manche ' + gameState.round;

  const isMyTurn = gameState.phase === 'playing' &&
    gameState.players[gameState.currentPlayerIndex]?.id === myPlayerId;

  // IMPROVEMENT: Trigger sound/notification/vibration when turn changes to me
  if (isMyTurn && !_wasMyTurnLastRender) {
    playMyTurnSound();
    sendTurnNotification();
    vibrateIfMobile();
  }
  _wasMyTurnLastRender = isMyTurn;

  // Status text
  if (gameState.phase === 'reveal_initial') {
    const myReveals = gameState.initialReveals[myPlayerId] || 0;
    statusEl.textContent = myReveals < 2
      ? `Retournez ${2 - myReveals} carte(s)`
      : 'En attente des autres joueurs...';
  } else if (gameState.phase === 'playing') {
    const cp = gameState.players[gameState.currentPlayerIndex];
    if (isMyTurn) {
      switch(gameState.turnPhase) {
        case 'draw': statusEl.textContent = 'üé¥ Piochez une carte'; break;
        case 'drawn_from_pile': statusEl.textContent = 'üìå Placez le ' + gameState.drawnCard + ' sur votre grille OU d√©faussez-le'; break;
        case 'place_mandatory': statusEl.textContent = 'üìå Vous DEVEZ placer le ' + gameState.drawnCard + ' sur votre grille'; break;
        case 'must_reveal': statusEl.textContent = 'üëÜ Retournez une carte face cach√©e de votre grille'; break;
        default: statusEl.textContent = '√Ä vous de jouer';
      }
    } else {
      statusEl.textContent = 'Tour de ' + cp.name;
      if (gameState.drawnCard !== null && gameState.drawnByPlayerId) {
        if (gameState.turnPhase === 'drawn_from_pile') statusEl.textContent += ' ‚Äî a pioch√© un ' + gameState.drawnCard;
        else if (gameState.turnPhase === 'place_mandatory') statusEl.textContent += ' ‚Äî doit placer le ' + gameState.drawnCard;
        else if (gameState.turnPhase === 'must_reveal') statusEl.textContent += ' ‚Äî doit retourner une carte';
      }
    }
    if (gameState.lastRoundTriggeredBy) statusEl.textContent += ' üîî Dernier tour !';
  }

  // Piles
  const discardTop = gameState.discard.length > 0 ? gameState.discard[gameState.discard.length - 1] : null;
  const deckCount = gameState.deck ? gameState.deck.length : 0;

  let pilesHtml = `<div class="pile">
    <div class="pile-label">Pioche (${deckCount})</div>
    <div class="card face-down" id="pile-deck" onclick="clickDeck()"></div>
  </div>`;

  pilesHtml += '<div class="pile"><div class="pile-label">D√©fausse</div>';
  if (discardTop !== null) {
    pilesHtml += `<div class="card ${getCardClass(discardTop)}" id="pile-discard" onclick="clickDiscard()">${discardTop}</div>`;
  } else {
    pilesHtml += '<div class="card face-down" style="opacity:.3"></div>';
  }
  pilesHtml += '</div>';

  if (gameState.drawnCard !== null && gameState.drawnByPlayerId) {
    const isDrawnByMe = gameState.drawnByPlayerId === myPlayerId;
    const drawerName = getPlayerName(gameState.drawnByPlayerId);
    pilesHtml += `<div class="pile"><div class="pile-label">${isDrawnByMe ? 'En main' : drawerName}</div>`;
    if (isMyTurn && gameState.turnPhase === 'drawn_from_pile') {
      pilesHtml += `<div class="card ${getCardClass(gameState.drawnCard)} highlight" onclick="discardDrawn()" title="Tap = d√©fausser">${gameState.drawnCard}</div>`;
      pilesHtml += '<div style="font-size:.65em;color:#e74c3c;margin-top:2px">Tap = d√©fausser</div>';
    } else {
      pilesHtml += `<div class="card ${getCardClass(gameState.drawnCard)} highlight">${gameState.drawnCard}</div>`;
    }
    pilesHtml += '</div>';
  }

  pilesArea.innerHTML = pilesHtml;

  // Players (mine first)
  const orderedPlayers = [...gameState.players].sort((a, b) => {
    if (a.id === myPlayerId) return -1;
    if (b.id === myPlayerId) return 1;
    return 0;
  });

  let playersHtml = '';
  orderedPlayers.forEach(p => {
    const isMe = p.id === myPlayerId;
    const isCurrent = gameState.phase === 'playing' && gameState.players[gameState.currentPlayerIndex]?.id === p.id;
    const visibleScore = calcVisibleScore(p.id);
    const totalScore = gameState.totalScores[p.id] || 0;

    playersHtml += `<div class="player-zone ${isCurrent ? 'current-turn' : ''} ${isMe ? 'is-me' : ''}">`;
    playersHtml += `<div class="player-header">`;
    playersHtml += `<span class="player-name">${p.name}${isMe ? ' <small style="color:#888;font-size:.75em">(vous)</small>' : ''}</span>`;
    playersHtml += `<span>`;
    if (isCurrent) playersHtml += `<span class="turn-indicator">‚ñ∂ </span>`;
    playersHtml += `<span class="player-score">Visible: ${visibleScore} | Total: ${totalScore}</span>`;
    playersHtml += `</span></div>`;

    playersHtml += '<div class="card-container">';
    for (let r = 0; r < ROWS; r++) {
      playersHtml += '<div class="card-row">';
      for (let c = 0; c < COLS; c++) {
        if (gameState.eliminated[p.id][c]) {
          playersHtml += '<div class="card eliminated"></div>';
        } else if (gameState.revealed[p.id][r][c]) {
          const val = gameState.hands[p.id][r][c];
          playersHtml += `<div class="card ${getCardClass(val)}">${val}</div>`;
        } else {
          const selectable = isCardSelectable(p.id, r, c);
          playersHtml += `<div class="card face-down ${selectable ? 'selectable' : ''}" onclick="clickCard('${p.id}',${r},${c})"></div>`;
        }
      }
      playersHtml += '</div>';
    }
    playersHtml += '</div></div>';
  });

  playersArea.innerHTML = playersHtml;

  // Make revealed cards clickable when player must place
  if (isMyTurn && (gameState.turnPhase === 'drawn_from_pile' || gameState.turnPhase === 'place_mandatory')) {
    playersArea.querySelectorAll('.player-zone.is-me .card:not(.eliminated)').forEach(cardEl => {
      if (!cardEl.classList.contains('face-down')) {
        const row = cardEl.closest('.card-row');
        const container = cardEl.closest('.card-container');
        if (row && container) {
          const rows = Array.from(container.children);
          const r = rows.indexOf(row);
          const cols = Array.from(row.children);
          const c = cols.indexOf(cardEl);
          if (r >= 0 && c >= 0 && !gameState.eliminated[myPlayerId][c]) {
            cardEl.style.cursor = 'pointer';
            cardEl.classList.add('selectable');
            cardEl.onclick = () => clickCard(myPlayerId, r, c);
          }
        }
      }
    });
  }

  // Action bar
  if (isMyTurn && gameState.turnPhase === 'drawn_from_pile') {
    actionBar.style.display = '';
    actionBar.innerHTML = `<button class="danger" onclick="discardDrawn()" style="font-size:1em;padding:14px 28px">üóëÔ∏è D√©fausser le ${gameState.drawnCard} et retourner une carte</button>`;
  } else if (isMyTurn && gameState.turnPhase === 'must_reveal') {
    actionBar.style.display = '';
    actionBar.innerHTML = '<div style="color:#f1c40f;font-weight:600;padding:8px">üëÜ Cliquez sur une carte face cach√©e pour la retourner</div>';
  } else {
    actionBar.style.display = 'none';
    actionBar.innerHTML = '';
  }
}


// ============================================================
// SECTION 24 ‚Äî RENDERING: ROUND REVEAL & SCORE SCREENS
// ============================================================

function renderRoundReveal(isGameOver) {
  document.getElementById('reveal-subtitle').textContent = isGameOver
    ? 'Grilles finales de la partie'
    : 'Manche ' + gameState.round + ' termin√©e !';

  const summary = document.getElementById('reveal-summary');
  let html = '';

  const sorted = [...gameState.players].sort((a, b) =>
    (gameState.roundScores[a.id] || 0) - (gameState.roundScores[b.id] || 0)
  );
  const bestScore = gameState.roundScores[sorted[0].id] || 0;

  sorted.forEach(p => {
    const rs = gameState.roundScores[p.id] || 0;
    const isBest = rs === bestScore;
    const isTriggerer = p.id === gameState.lastRoundTriggeredBy;
    const isMe = p.id === myPlayerId;
    const sign = rs > 0 ? '+' : '';

    let gridHtml = '<div class="pr-grid">';
    for (let r = 0; r < ROWS; r++) {
      for (let c = 0; c < COLS; c++) {
        if (gameState.eliminated[p.id][c]) {
          gridHtml += '<div class="mini-card empty"></div>';
        } else {
          const val = gameState.hands[p.id][r][c];
          gridHtml += `<div class="mini-card ${getCardClass(val)}">${val}</div>`;
        }
      }
    }
    gridHtml += '</div>';

    const badge = isTriggerer ? ' üîî' : (isBest ? ' ‚ú®' : '');
    html += `<div class="player-result ${isBest ? 'best' : ''}">
      <div class="pr-name">${p.name}${badge}${isMe ? '<small>vous</small>' : ''}</div>
      ${gridHtml}
      <span class="score-val">${sign}${rs}</span>
    </div>`;
  });

  summary.innerHTML = html;
}

function showRoundScoreTable() {
  if (!gameState) return;
  if (gameState.phase === 'game_over_reveal') {
    const sorted = [...gameState.players].sort((a, b) =>
      (gameState.totalScores[a.id] || 0) - (gameState.totalScores[b.id] || 0)
    );
    gameState.players.forEach(p => {
      updateLeaderboard(p.name, p.id === sorted[0].id);
    });
    gameState.phase = 'game_over';
  } else {
    gameState.phase = 'round_end';
  }
  if (isHost) broadcastState();
  else renderFromState();
}

function renderRoundScores() {
  const table = document.getElementById('round-scores-table');
  const sub = document.getElementById('round-scores-subtitle');
  if (sub) sub.textContent = 'Manche ' + gameState.round + ' sur ' + gameState.round;

  let html = '<thead><tr><th>Joueur</th><th>Manche</th><th>Total</th></tr></thead><tbody>';
  const sorted = [...gameState.players].sort((a, b) =>
    (gameState.totalScores[a.id] || 0) - (gameState.totalScores[b.id] || 0)
  );
  sorted.forEach((p, i) => {
    const rs = gameState.roundScores[p.id] || 0;
    const ts = gameState.totalScores[p.id] || 0;
    const isTriggerer = p.id === gameState.lastRoundTriggeredBy;
    const isMe = p.id === myPlayerId;
    const scoreClass = rs > 0 ? 'round-score-pos' : (rs < 0 ? 'round-score-neg' : '');
    const sign = rs > 0 ? '+' : '';
    html += `<tr${i === 0 ? ' class="winner"' : ''}>`;
    html += `<td>${i === 0 ? '<span class="winner-name">' : ''}${p.name}${isTriggerer ? ' üîî' : ''}${isMe ? '<br><small style="color:#888;font-size:.72em;font-weight:400">vous</small>' : ''}${i === 0 ? '</span>' : ''}</td>`;
    html += `<td class="${scoreClass}">${sign}${rs}</td>`;
    html += `<td class="total">${ts}</td></tr>`;
  });
  html += '</tbody>';
  table.innerHTML = html;

  const durEl = document.getElementById('round-duration');
  const durVal = document.getElementById('round-duration-value');
  if (durEl && durVal) {
    const dur = gameState.gameStartTime ? formatDuration(Date.now() - gameState.gameStartTime) : null;
    if (dur) { durVal.textContent = dur; durEl.style.display = ''; }
    else { durEl.style.display = 'none'; }
  }
  document.getElementById('next-round-btn').style.display = isHost ? '' : 'none';
}

function renderFinalScores() {
  const sorted = [...gameState.players].sort((a, b) =>
    (gameState.totalScores[a.id] || 0) - (gameState.totalScores[b.id] || 0)
  );
  const winner = sorted[0];
  document.getElementById('final-winner-banner').innerHTML =
    `<div class="winner-name">üéâ ${winner.name} remporte la partie ! üéâ</div>`;

  const cardsEl = document.getElementById('final-score-cards');
  if (cardsEl) {
    const medals = ['ü•á', 'ü•à', 'ü•â'];
    let html = '';
    sorted.forEach((p, i) => {
      const ts = gameState.totalScores[p.id] || 0;
      const medal = medals[i] || (i + 1);
      const rankClass = i < 3 ? `rank-${i + 1}` : '';
      const isMe = p.id === myPlayerId;
      html += `<div class="score-card ${rankClass}">
        <div class="score-card-medal">${medal}</div>
        <div class="score-card-name">
          ${i === 0 ? `<span class="winner-name" style="font-size:.95em">${p.name}</span>` : p.name}
          ${isMe ? '<small>vous</small>' : ''}
        </div>
        <div class="score-card-pts">${ts} pts</div>
      </div>`;
    });
    cardsEl.innerHTML = html;
  }

  const durEl = document.getElementById('final-duration');
  const durVal = document.getElementById('final-duration-value');
  if (durEl && durVal) {
    const dur = gameState.gameStartTime ? formatDuration(Date.now() - gameState.gameStartTime) : null;
    if (dur) { durVal.textContent = dur; durEl.style.display = ''; }
    else { durEl.style.display = 'none'; }
  }
  renderLeaderboard('final-leaderboard');
}


// ============================================================
// SECTION 25 ‚Äî RENDERING: HELPERS
// ============================================================

function isCardSelectable(playerId, row, col) {
  if (gameState.eliminated[playerId][col]) return false;
  const isMe = playerId === myPlayerId;
  if (gameState.phase === 'reveal_initial') {
    return isMe && !gameState.revealed[playerId][row][col] && (gameState.initialReveals[playerId] || 0) < 2;
  }
  if (gameState.phase === 'playing') {
    const isMyTurn = gameState.players[gameState.currentPlayerIndex]?.id === myPlayerId;
    if (!isMe || !isMyTurn) return false;
    if (gameState.turnPhase === 'must_reveal') return !gameState.revealed[playerId][row][col];
    if (gameState.turnPhase === 'drawn_from_pile' || gameState.turnPhase === 'place_mandatory') return true;
  }
  return false;
}

function getCardClass(val) {
  if (val <= -2) return 'val-neg2';
  if (val === -1) return 'val-neg1';
  if (val === 0) return 'val-0';
  return 'val-' + val;
}

function calcVisibleScore(playerId) {
  let sum = 0;
  for (let r = 0; r < ROWS; r++) {
    for (let c = 0; c < COLS; c++) {
      if (gameState.eliminated[playerId][c]) continue;
      if (gameState.revealed[playerId][r][c]) sum += gameState.hands[playerId][r][c];
    }
  }
  return sum;
}

function formatDuration(ms) {
  if (!ms || ms <= 0) return null;
  const totalSec = Math.floor(ms / 1000);
  const h = Math.floor(totalSec / 3600);
  const m = Math.floor((totalSec % 3600) / 60);
  const s = totalSec % 60;
  if (h > 0) return `${h}h ${m}min ${s}s`;
  if (m > 0) return `${m}min ${s}s`;
  return `${s}s`;
}


// ============================================================
// SECTION 26 ‚Äî CLICK HANDLERS
// ============================================================

function clickDeck() {
  const isMyTurn = gameState.phase === 'playing' &&
    gameState.players[gameState.currentPlayerIndex]?.id === myPlayerId;
  if (!isMyTurn || gameState.turnPhase !== 'draw') return;
  playCardFlip();
  performAction({ type: 'draw_deck' });
}

function clickDiscard() {
  const isMyTurn = gameState.phase === 'playing' &&
    gameState.players[gameState.currentPlayerIndex]?.id === myPlayerId;
  if (!isMyTurn || gameState.turnPhase !== 'draw') return;
  playCardFlip();
  performAction({ type: 'draw_discard' });
}

function clickCard(playerId, row, col) {
  if (gameState.phase === 'reveal_initial') {
    if (playerId !== myPlayerId) return;
    playCardFlip();
    performAction({ type: 'reveal', row, col });
    return;
  }
  if (gameState.phase === 'playing') {
    const isMyTurn = gameState.players[gameState.currentPlayerIndex]?.id === myPlayerId;
    if (!isMyTurn || playerId !== myPlayerId) return;
    if (gameState.turnPhase === 'must_reveal') {
      if (!gameState.revealed[playerId][row][col]) {
        playCardFlip();
        performAction({ type: 'reveal_card', row, col });
      }
      return;
    }
    if (gameState.turnPhase === 'drawn_from_pile' || gameState.turnPhase === 'place_mandatory') {
      if (!gameState.eliminated[playerId][col]) {
        playCardFlip();
        performAction({ type: 'place_card', row, col });
      }
      return;
    }
  }
}

function discardDrawn() {
  playCardFlip();
  performAction({ type: 'discard_drawn' });
}


// ============================================================
// SECTION 27 ‚Äî RULES MODAL & TOAST
// ============================================================

function showRules() {
  showModal('R√®gles Skyjo', `
    <div style="text-align:left;font-size:.85em;max-height:60vh;overflow-y:auto;line-height:1.6">
    <b>But :</b> Avoir le score le plus bas √† la fin de la partie.<br><br>
    <b>D√©but :</b> Chaque joueur retourne 2 cartes. Le joueur avec la plus haute somme commence.<br><br>
    <b>Tour :</b><br>
    ‚Ä¢ Piochez depuis la <b>pioche</b> ou la <b>d√©fausse</b><br>
    ‚Ä¢ Si pioche : placez la carte sur votre grille OU d√©faussez-la et retournez une carte face cach√©e<br>
    ‚Ä¢ Si d√©fausse : vous DEVEZ placer la carte sur votre grille<br><br>
    <b>Colonnes :</b> 3 cartes identiques dans une colonne ‚Üí √©limin√©es !<br><br>
    <b>Fin de manche :</b> Quand un joueur a toutes ses cartes visibles, chaque autre joueur joue un dernier tour.<br><br>
    <b>Score doubl√© :</b> Si le joueur qui termine n'a pas le score le plus bas, son score est doubl√© !<br><br>
    <b>Fin de partie :</b> Quand un joueur atteint 100 points. Le joueur avec le score le plus bas gagne !<br><br>
    <b>Valeurs :</b> -2 (√ó5), -1 (√ó10), 0 (√ó15), 1-12 (√ó10 chaque)
    </div>
  `, [{ text: 'Compris !', action: 'closeModal()' }]);
}

function showModal(title, text, buttons) {
  document.getElementById('modal-title').textContent = title;
  document.getElementById('modal-text').innerHTML = text;
  const btnContainer = document.getElementById('modal-buttons');
  btnContainer.innerHTML = buttons.map(b =>
    `<button onclick="${b.action}">${b.text}</button>`
  ).join('');
  document.getElementById('modal').classList.add('active');
}

function closeModal() {
  document.getElementById('modal').classList.remove('active');
}

function toast(msg) {
  const el = document.getElementById('toast');
  el.textContent = msg;
  el.classList.add('show');
  setTimeout(() => el.classList.remove('show'), 2500);
}


// ============================================================
// SECTION 28 ‚Äî URL PARAMS (auto-join via shared link)
// ============================================================

window.addEventListener('load', () => {
  const params = new URLSearchParams(window.location.search);
  const room = params.get('room');
  if (room) {
    document.getElementById('room-input').value = room;
    showJoinScreen();
  }
  renderLeaderboard('menu-leaderboard');
});

</script>
</body>
</html>
